/* Server_SoapStub.h
   Generated by gSOAP 2.8.27 from F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#include <time.h>

#ifndef Server_SoapStub_H
#define Server_SoapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20827
# error "GSOAP VERSION 20827 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:11 */
#ifndef SOAP_TYPE_ns__SettingLevel
#define SOAP_TYPE_ns__SettingLevel (10)
/* ns:SettingLevel */
enum ns__SettingLevel
{
	Normal = 0,
	Disable = 1,
	Warning = 2,
	Minor = 3,
	Major = 4,
	Critical = 5
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:21 */
#ifndef SOAP_TYPE_ns__UserType
#define SOAP_TYPE_ns__UserType (11)
/* ns:UserType */
enum ns__UserType
{
	Admin = 0,
	Control = 1,
	Monitor = 2
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:28 */
#ifndef SOAP_TYPE_ns__SimcardType
#define SOAP_TYPE_ns__SimcardType (12)
/* ns:SimcardType */
enum ns__SimcardType
{
	MCI = 0,
	IranCell = 1,
	Taliya = 2,
	RighTel = 3,
	UnknownSim = 4
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:37 */
#ifndef SOAP_TYPE_ns__SensorType
#define SOAP_TYPE_ns__SensorType (13)
/* ns:SensorType */
enum ns__SensorType
{
	Multi = 0,
	Mono = 1
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:43 */
#ifndef SOAP_TYPE_ns__SensorName
#define SOAP_TYPE_ns__SensorName (14)
/* ns:SensorName */
enum ns__SensorName
{
	TEMPERATURE = 0,
	HUMIDITY = 1,
	H2S = 2,
	PRESSER = 3,
	GAS = 4,
	ACVOLTAGE = 5,
	ACVOLTAGE1 = 6,
	ACVOLTAGE2 = 7,
	ACVOLTAGE3 = 8,
	ACAMPERE = 9,
	ACAMPERE1 = 10,
	ACAMPERE2 = 11,
	ACAMPERE3 = 12,
	DCVOLTAGE = 13,
	DCAMPERE = 14,
	SMOKE = 15,
	MAGNET = 16,
	WATER = 17,
	MOTION = 18,
	DIGITAL = 19,
	UNKNOWN = 20
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* struct_tm.h:101 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (9)
typedef struct tm xsd__dateTime;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

class ns__ErrorCode;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:75 */
class ns__User;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:82 */
class ns__UsersList;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:96 */
class ns__IP;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:102 */
class ns__Server;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:110 */
class ns__Gprs;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:118 */
class ns__Mobile;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:126 */
class ns__Relay;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:134 */
class ns__Sensor;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:140 */
class ns__Device;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:158 */
class ns__Report;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:186 */
class ns__ActivityLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:192 */
class ns__UserLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:201 */
class ns__DeviceStatusLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:209 */
class ns__DeviceStatusLogList;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:216 */
class ns__DeviceStatusInfo;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:223 */
class ns__ErrorLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:230 */
class ns__DeviceRules;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:238 */
class ns__UserDevices;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:246 */
class ns__UserDevice;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:252 */
class ns__DataBaseInfo;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:259 */
class ns__ServerOptions;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:268 */
class ns__CityLocation;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:275 */
class ns__AllCityLocatoins;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:282 */
struct ns__GetDeviceStatus;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:288 */
struct ns__GetAllDeviceStatus;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:289 */
struct ns__SetDeviceSetting;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:290 */
struct ns__SetAllDeviceSettingResponse;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:291 */
struct ns__SetAllDeviceSetting;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:291 */
struct ns__DeleteDevices;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:292 */
struct ns__Login;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:294 */
struct ns__GetUserDeviceList;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:295 */
struct ns__GetAllDeviceList;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:296 */
struct ns__GetUsersList;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:298 */
struct ns__AddUser;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:299 */
struct ns__UpdateUser;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:300 */
struct ns__DeleteUser;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:301 */
struct ns__AssignDeviceToUser;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:302 */
struct ns__DeleteDeviceFromUserList;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:303 */
struct ns__GetUserDevices;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:304 */
struct ns__SaveActivityLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:306 */
struct ns__GetActivityLogResponse;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:307 */
struct ns__GetActivityLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:307 */
struct ns__SaveUserLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:308 */
struct ns__GetUserLogResponse;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:309 */
struct ns__GetUserLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:309 */
struct ns__SaveDeviceStatusLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:310 */
struct ns__GetDeviceStatusLog;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:311 */
struct ns__GetServerOptions;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:313 */
struct ns__SetServerOptions;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:314 */
struct ns__GetCityAndLocations;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:316 */
struct ns__ChangeCityName;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:317 */
struct ns__ChangeLocationName;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:318 */
struct ns__ChangeDeviceName;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:319 */
struct ns__TestWorldResponse;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
struct ns__TestWorld;	/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */

/* struct_tm.h:91 */
#ifndef SOAP_TYPE_tm
#define SOAP_TYPE_tm (8)
#if 0 /* Volatile: not declared here because it is declared already in a library or in other parts of the user's project */
struct tm
{
public:
	int tm_sec;	/* optional element of XSD type xsd:int */
	int tm_min;	/* optional element of XSD type xsd:int */
	int tm_hour;	/* optional element of XSD type xsd:int */
	int tm_mday;	/* optional element of XSD type xsd:int */
	int tm_mon;	/* optional element of XSD type xsd:int */
	int tm_year;	/* optional element of XSD type xsd:int */
	int tm_isdst;	/* required element of XSD type xsd:int */
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:75 */
#ifndef SOAP_TYPE_ns__ErrorCode
#define SOAP_TYPE_ns__ErrorCode (26)
/* ns:ErrorCode complex type: */
class SOAP_CMAC ns__ErrorCode
{
public:
	int errorNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:int */
	std::string errorMessage;	/* optional element of XSD type xsd:string */
	enum ns__SettingLevel errorType;	/* optional element of XSD type ns:SettingLevel */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ErrorCode (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__ErrorCode, default initialized and not managed by a soap context
	virtual ns__ErrorCode *soap_alloc(void) const { return SOAP_NEW(ns__ErrorCode); }
	         ns__ErrorCode() { ns__ErrorCode::soap_default(NULL); }
	virtual ~ns__ErrorCode() { }
	friend ns__ErrorCode *soap_instantiate_ns__ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:82 */
#ifndef SOAP_TYPE_ns__User
#define SOAP_TYPE_ns__User (27)
/* ns:User complex type: */
class SOAP_CMAC ns__User
{
public:
	int userId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:int */
	std::string userName;	/* optional element of XSD type xsd:string */
	std::string userPassword;	/* optional element of XSD type xsd:string */
	std::string userNewPassword;	/* optional element of XSD type xsd:string */
	std::string userFirstName;	/* optional element of XSD type xsd:string */
	std::string userLastName;	/* optional element of XSD type xsd:string */
	enum ns__UserType userType;	/* optional element of XSD type ns:UserType */
	std::string userKey;	/* optional element of XSD type xsd:string */
	struct tm userSubmitDateTime;	/* external (custom serializer) */
	ns__ErrorCode userError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__User (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__User, default initialized and not managed by a soap context
	virtual ns__User *soap_alloc(void) const { return SOAP_NEW(ns__User); }
	         ns__User() { ns__User::soap_default(NULL); }
	virtual ~ns__User() { }
	friend ns__User *soap_instantiate_ns__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:96 */
#ifndef SOAP_TYPE_ns__UsersList
#define SOAP_TYPE_ns__UsersList (28)
/* ns:UsersList complex type: */
class SOAP_CMAC ns__UsersList
{
public:
	std::vector<ns__User> usersListUsers;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns:User */
	ns__ErrorCode usersListError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__UsersList (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__UsersList, default initialized and not managed by a soap context
	virtual ns__UsersList *soap_alloc(void) const { return SOAP_NEW(ns__UsersList); }
	         ns__UsersList() { ns__UsersList::soap_default(NULL); }
	virtual ~ns__UsersList() { }
	friend ns__UsersList *soap_instantiate_ns__UsersList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:102 */
#ifndef SOAP_TYPE_ns__IP
#define SOAP_TYPE_ns__IP (30)
/* ns:IP complex type: */
class SOAP_CMAC ns__IP
{
public:
	int ipFirst;	/* optional element of XSD type xsd:int */
	int ipSecond;	/* optional element of XSD type xsd:int */
	int ipThird;	/* optional element of XSD type xsd:int */
	int ipFourth;	/* optional element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__IP (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__IP, default initialized and not managed by a soap context
	virtual ns__IP *soap_alloc(void) const { return SOAP_NEW(ns__IP); }
	         ns__IP() { ns__IP::soap_default(NULL); }
	virtual ~ns__IP() { }
	friend ns__IP *soap_instantiate_ns__IP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:110 */
#ifndef SOAP_TYPE_ns__Server
#define SOAP_TYPE_ns__Server (31)
/* ns:Server complex type: */
class SOAP_CMAC ns__Server
{
public:
	std::string serverDNSAddress;	/* required element of XSD type xsd:string */
	ns__IP serverIP;	/* required element of XSD type ns:IP */
	int serverPort;	/* optional element of XSD type xsd:int */
	ns__ErrorCode serverError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__Server (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__Server, default initialized and not managed by a soap context
	virtual ns__Server *soap_alloc(void) const { return SOAP_NEW(ns__Server); }
	         ns__Server() { ns__Server::soap_default(NULL); }
	virtual ~ns__Server() { }
	friend ns__Server *soap_instantiate_ns__Server(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:118 */
#ifndef SOAP_TYPE_ns__Gprs
#define SOAP_TYPE_ns__Gprs (32)
/* ns:Gprs complex type: */
class SOAP_CMAC ns__Gprs
{
public:
	std::string gprsDNSAddress;	/* required element of XSD type xsd:string */
	ns__IP gprsIP;	/* required element of XSD type ns:IP */
	int gprsPort;	/* optional element of XSD type xsd:int */
	ns__ErrorCode gprsError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__Gprs (32)
	virtual int soap_type(void) const { return 32; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__Gprs, default initialized and not managed by a soap context
	virtual ns__Gprs *soap_alloc(void) const { return SOAP_NEW(ns__Gprs); }
	         ns__Gprs() { ns__Gprs::soap_default(NULL); }
	virtual ~ns__Gprs() { }
	friend ns__Gprs *soap_instantiate_ns__Gprs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:126 */
#ifndef SOAP_TYPE_ns__Mobile
#define SOAP_TYPE_ns__Mobile (33)
/* ns:Mobile complex type: */
class SOAP_CMAC ns__Mobile
{
public:
	LONG64 mobileNumber;	/* optional element of XSD type xsd:long */
	enum ns__SimcardType mobileSimCardType;	/* optional element of XSD type ns:SimcardType */
	int mobileChargeValue;	/* optional element of XSD type xsd:int */
	int mobileSignalValue;	/* optional element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__Mobile (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__Mobile, default initialized and not managed by a soap context
	virtual ns__Mobile *soap_alloc(void) const { return SOAP_NEW(ns__Mobile); }
	         ns__Mobile() { ns__Mobile::soap_default(NULL); }
	virtual ~ns__Mobile() { }
	friend ns__Mobile *soap_instantiate_ns__Mobile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:134 */
#ifndef SOAP_TYPE_ns__Relay
#define SOAP_TYPE_ns__Relay (34)
/* ns:Relay complex type: */
class SOAP_CMAC ns__Relay
{
public:
	int relayIndex;	/* optional element of XSD type xsd:int */
	bool relayOnOff;	/* optional element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__Relay (34)
	virtual int soap_type(void) const { return 34; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__Relay, default initialized and not managed by a soap context
	virtual ns__Relay *soap_alloc(void) const { return SOAP_NEW(ns__Relay); }
	         ns__Relay() { ns__Relay::soap_default(NULL); }
	virtual ~ns__Relay() { }
	friend ns__Relay *soap_instantiate_ns__Relay(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:140 */
#ifndef SOAP_TYPE_ns__Sensor
#define SOAP_TYPE_ns__Sensor (35)
/* ns:Sensor complex type: */
class SOAP_CMAC ns__Sensor
{
public:
	enum ns__SensorName sensorName;	/* optional element of XSD type ns:SensorName */
	std::string sensorNikeName;	/* optional element of XSD type xsd:string */
	double sensorValue;	/* optional element of XSD type xsd:double */
	int sensorCalibration;	/* optional element of XSD type xsd:int */
	int sensorMinimumValue;	/* optional element of XSD type xsd:int */
	int sensorMaximumValue;	/* optional element of XSD type xsd:int */
	int sensorMaximumThreshold;	/* optional element of XSD type xsd:int */
	int sensorMinimumThreshold;	/* optional element of XSD type xsd:int */
	bool sensorSMSOnOff;	/* optional element of XSD type xsd:boolean */
	bool sensorBuzzerOnOff;	/* optional element of XSD type xsd:boolean */
	ns__Relay sensorRelay;	/* required element of XSD type ns:Relay */
	bool sensorLEDFlag;	/* optional element of XSD type xsd:boolean */
	enum ns__SensorType sensorType;	/* optional element of XSD type ns:SensorType */
	ns__ErrorCode sensorError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__Sensor (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__Sensor, default initialized and not managed by a soap context
	virtual ns__Sensor *soap_alloc(void) const { return SOAP_NEW(ns__Sensor); }
	         ns__Sensor() { ns__Sensor::soap_default(NULL); }
	virtual ~ns__Sensor() { }
	friend ns__Sensor *soap_instantiate_ns__Sensor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:158 */
#ifndef SOAP_TYPE_ns__Device
#define SOAP_TYPE_ns__Device (37)
/* ns:Device complex type: */
class SOAP_CMAC ns__Device
{
public:
	int deviceSerialNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:int */
	std::string deviceName;	/* optional element of XSD type xsd:string */
	std::string deviceFirmWareVersion;	/* optional element of XSD type xsd:string */
	std::string deviceNikeName;	/* optional element of XSD type xsd:string */
	std::string deviceLocation;	/* optional element of XSD type xsd:string */
	std::string deviceCity;	/* optional element of XSD type xsd:string */
	int deviceSocket;	/* optional element of XSD type xsd:int */
	std::string deviceDNSAddress;	/* required element of XSD type xsd:string */
	ns__IP deviceIP;	/* required element of XSD type ns:IP */
	int devicePort;	/* optional element of XSD type xsd:int */
	struct tm deviceDateTime;	/* external (custom serializer) */
	ns__Mobile deviceMobileInfo;	/* required element of XSD type ns:Mobile */
	ns__Server deviceServerInfo;	/* required element of XSD type ns:Server */
	ns__Gprs deviceGprsInfo;	/* required element of XSD type ns:Gprs */
	std::vector<LONG64> deviceSMSContact;	/* optional element of XSD type xsd:long */
	std::vector<LONG64> deviceSMSConfig;	/* optional element of XSD type xsd:long */
	std::string deviceFlags;	/* optional element of XSD type xsd:string */
	bool deviceSMSCommand;	/* optional element of XSD type xsd:boolean */
	bool deviceGSMCommand;	/* optional element of XSD type xsd:boolean */
	bool deviceKeyBoardCommand;	/* optional element of XSD type xsd:boolean */
	bool deviceBuzzerOnOff;	/* optional element of XSD type xsd:boolean */
	bool deviceReset;	/* optional element of XSD type xsd:boolean */
	std::vector<ns__Sensor> deviceSensors;	/* optional element of XSD type ns:Sensor */
	ns__ErrorCode deviceError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__Device (37)
	virtual int soap_type(void) const { return 37; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__Device, default initialized and not managed by a soap context
	virtual ns__Device *soap_alloc(void) const { return SOAP_NEW(ns__Device); }
	         ns__Device() { ns__Device::soap_default(NULL); }
	virtual ~ns__Device() { }
	friend ns__Device *soap_instantiate_ns__Device(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:186 */
#ifndef SOAP_TYPE_ns__Report
#define SOAP_TYPE_ns__Report (40)
/* ns:Report complex type: */
class SOAP_CMAC ns__Report
{
public:
	struct tm reportStartDate;	/* external (custom serializer) */
	struct tm reportEndDate;	/* external (custom serializer) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__Report (40)
	virtual int soap_type(void) const { return 40; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__Report, default initialized and not managed by a soap context
	virtual ns__Report *soap_alloc(void) const { return SOAP_NEW(ns__Report); }
	         ns__Report() { ns__Report::soap_default(NULL); }
	virtual ~ns__Report() { }
	friend ns__Report *soap_instantiate_ns__Report(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:192 */
#ifndef SOAP_TYPE_ns__ActivityLog
#define SOAP_TYPE_ns__ActivityLog (41)
/* ns:ActivityLog complex type: */
class SOAP_CMAC ns__ActivityLog
{
public:
	ns__Report activityLogStartEndDateTime;	/* required element of XSD type ns:Report */
	std::string activityLogData;	/* optional element of XSD type xsd:string */
	ns__Device activityLogDevice;	/* required element of XSD type ns:Device */
	ns__User activityLogUser;	/* required element of XSD type ns:User */
	ns__ErrorCode activityError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ActivityLog (41)
	virtual int soap_type(void) const { return 41; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__ActivityLog, default initialized and not managed by a soap context
	virtual ns__ActivityLog *soap_alloc(void) const { return SOAP_NEW(ns__ActivityLog); }
	         ns__ActivityLog() { ns__ActivityLog::soap_default(NULL); }
	virtual ~ns__ActivityLog() { }
	friend ns__ActivityLog *soap_instantiate_ns__ActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:201 */
#ifndef SOAP_TYPE_ns__UserLog
#define SOAP_TYPE_ns__UserLog (42)
/* ns:UserLog complex type: */
class SOAP_CMAC ns__UserLog
{
public:
	ns__Report userLogStartEndDateTime;	/* required element of XSD type ns:Report */
	std::string userLogData;	/* optional element of XSD type xsd:string */
	ns__User userLogUser;	/* required element of XSD type ns:User */
	ns__ErrorCode userLogError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__UserLog (42)
	virtual int soap_type(void) const { return 42; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__UserLog, default initialized and not managed by a soap context
	virtual ns__UserLog *soap_alloc(void) const { return SOAP_NEW(ns__UserLog); }
	         ns__UserLog() { ns__UserLog::soap_default(NULL); }
	virtual ~ns__UserLog() { }
	friend ns__UserLog *soap_instantiate_ns__UserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:209 */
#ifndef SOAP_TYPE_ns__DeviceStatusLog
#define SOAP_TYPE_ns__DeviceStatusLog (43)
/* ns:DeviceStatusLog complex type: */
class SOAP_CMAC ns__DeviceStatusLog
{
public:
	ns__Report statusLogStartEndDateTime;	/* required element of XSD type ns:Report */
	ns__Device statusLogDevice;	/* required element of XSD type ns:Device */
	ns__ErrorCode statusLogError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__DeviceStatusLog (43)
	virtual int soap_type(void) const { return 43; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__DeviceStatusLog, default initialized and not managed by a soap context
	virtual ns__DeviceStatusLog *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusLog); }
	         ns__DeviceStatusLog() { ns__DeviceStatusLog::soap_default(NULL); }
	virtual ~ns__DeviceStatusLog() { }
	friend ns__DeviceStatusLog *soap_instantiate_ns__DeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:216 */
#ifndef SOAP_TYPE_ns__DeviceStatusLogList
#define SOAP_TYPE_ns__DeviceStatusLogList (44)
/* ns:DeviceStatusLogList complex type: */
class SOAP_CMAC ns__DeviceStatusLogList
{
public:
	std::vector<ns__DeviceStatusLog> statusLogListStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns:DeviceStatusLog */
	ns__ErrorCode statusLogListError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__DeviceStatusLogList (44)
	virtual int soap_type(void) const { return 44; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__DeviceStatusLogList, default initialized and not managed by a soap context
	virtual ns__DeviceStatusLogList *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusLogList); }
	         ns__DeviceStatusLogList() { ns__DeviceStatusLogList::soap_default(NULL); }
	virtual ~ns__DeviceStatusLogList() { }
	friend ns__DeviceStatusLogList *soap_instantiate_ns__DeviceStatusLogList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:223 */
#ifndef SOAP_TYPE_ns__DeviceStatusInfo
#define SOAP_TYPE_ns__DeviceStatusInfo (46)
/* ns:DeviceStatusInfo complex type: */
class SOAP_CMAC ns__DeviceStatusInfo
{
public:
	ns__Report deviceStatusInfoStartEndDateTime;	/* required element of XSD type ns:Report */
	std::vector<ns__Device> deviceStatusInfoDevice;	/* optional element of XSD type ns:Device */
	std::vector<std::string> deviceStatusInfoErrorType;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__DeviceStatusInfo (46)
	virtual int soap_type(void) const { return 46; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__DeviceStatusInfo, default initialized and not managed by a soap context
	virtual ns__DeviceStatusInfo *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusInfo); }
	         ns__DeviceStatusInfo() { ns__DeviceStatusInfo::soap_default(NULL); }
	virtual ~ns__DeviceStatusInfo() { }
	friend ns__DeviceStatusInfo *soap_instantiate_ns__DeviceStatusInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:230 */
#ifndef SOAP_TYPE_ns__ErrorLog
#define SOAP_TYPE_ns__ErrorLog (49)
/* ns:ErrorLog complex type: */
class SOAP_CMAC ns__ErrorLog
{
public:
	struct tm errorLogDateTime;	/* external (custom serializer) */
	ns__Device errorLogDevice;	/* required element of XSD type ns:Device */
	std::string errorLogType;	/* optional element of XSD type xsd:string */
	ns__ErrorCode errorLogError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ErrorLog (49)
	virtual int soap_type(void) const { return 49; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__ErrorLog, default initialized and not managed by a soap context
	virtual ns__ErrorLog *soap_alloc(void) const { return SOAP_NEW(ns__ErrorLog); }
	         ns__ErrorLog() { ns__ErrorLog::soap_default(NULL); }
	virtual ~ns__ErrorLog() { }
	friend ns__ErrorLog *soap_instantiate_ns__ErrorLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:238 */
#ifndef SOAP_TYPE_ns__DeviceRules
#define SOAP_TYPE_ns__DeviceRules (50)
/* ns:DeviceRules complex type: */
class SOAP_CMAC ns__DeviceRules
{
public:
	ns__Device userDeviceDevice;	/* required element of XSD type ns:Device */
	bool userDeviceView;	/* optional element of XSD type xsd:boolean */
	bool userDeviceUpdate;	/* optional element of XSD type xsd:boolean */
	bool userDeviceDelete;	/* optional element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__DeviceRules (50)
	virtual int soap_type(void) const { return 50; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__DeviceRules, default initialized and not managed by a soap context
	virtual ns__DeviceRules *soap_alloc(void) const { return SOAP_NEW(ns__DeviceRules); }
	         ns__DeviceRules() { ns__DeviceRules::soap_default(NULL); }
	virtual ~ns__DeviceRules() { }
	friend ns__DeviceRules *soap_instantiate_ns__DeviceRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:246 */
#ifndef SOAP_TYPE_ns__UserDevices
#define SOAP_TYPE_ns__UserDevices (51)
/* ns:UserDevices complex type: */
class SOAP_CMAC ns__UserDevices
{
public:
	std::vector<ns__DeviceRules> userDevices;	/* optional element of XSD type ns:DeviceRules */
	ns__ErrorCode userDeviceError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__UserDevices (51)
	virtual int soap_type(void) const { return 51; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__UserDevices, default initialized and not managed by a soap context
	virtual ns__UserDevices *soap_alloc(void) const { return SOAP_NEW(ns__UserDevices); }
	         ns__UserDevices() { ns__UserDevices::soap_default(NULL); }
	virtual ~ns__UserDevices() { }
	friend ns__UserDevices *soap_instantiate_ns__UserDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:252 */
#ifndef SOAP_TYPE_ns__UserDevice
#define SOAP_TYPE_ns__UserDevice (53)
/* ns:UserDevice complex type: */
class SOAP_CMAC ns__UserDevice
{
public:
	ns__User userDeviceUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns:User */
	ns__UserDevices userDeviceDevices;	/* required element of XSD type ns:UserDevices */
	ns__ErrorCode userDeviceError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__UserDevice (53)
	virtual int soap_type(void) const { return 53; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__UserDevice, default initialized and not managed by a soap context
	virtual ns__UserDevice *soap_alloc(void) const { return SOAP_NEW(ns__UserDevice); }
	         ns__UserDevice() { ns__UserDevice::soap_default(NULL); }
	virtual ~ns__UserDevice() { }
	friend ns__UserDevice *soap_instantiate_ns__UserDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:259 */
#ifndef SOAP_TYPE_ns__DataBaseInfo
#define SOAP_TYPE_ns__DataBaseInfo (54)
/* ns:DataBaseInfo complex type: */
class SOAP_CMAC ns__DataBaseInfo
{
public:
	std::string dataBaseInfoServerName;	/* optional element of XSD type xsd:string */
	int dataBaseInfoPort;	/* optional element of XSD type xsd:int */
	std::string dataBaseInfoUserName;	/* optional element of XSD type xsd:string */
	std::string dataBaseInfoPassWord;	/* optional element of XSD type xsd:string */
	ns__ErrorCode dataBaseInfoError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__DataBaseInfo (54)
	virtual int soap_type(void) const { return 54; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__DataBaseInfo, default initialized and not managed by a soap context
	virtual ns__DataBaseInfo *soap_alloc(void) const { return SOAP_NEW(ns__DataBaseInfo); }
	         ns__DataBaseInfo() { ns__DataBaseInfo::soap_default(NULL); }
	virtual ~ns__DataBaseInfo() { }
	friend ns__DataBaseInfo *soap_instantiate_ns__DataBaseInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:268 */
#ifndef SOAP_TYPE_ns__ServerOptions
#define SOAP_TYPE_ns__ServerOptions (55)
/* ns:ServerOptions complex type: */
class SOAP_CMAC ns__ServerOptions
{
public:
	ns__DataBaseInfo serverOptionsDataBaseInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns:DataBaseInfo */
	int serverOptionsTimeRepeat;	/* optional element of XSD type xsd:int */
	ns__ErrorCode serverOptionsError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ServerOptions (55)
	virtual int soap_type(void) const { return 55; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__ServerOptions, default initialized and not managed by a soap context
	virtual ns__ServerOptions *soap_alloc(void) const { return SOAP_NEW(ns__ServerOptions); }
	         ns__ServerOptions() { ns__ServerOptions::soap_default(NULL); }
	virtual ~ns__ServerOptions() { }
	friend ns__ServerOptions *soap_instantiate_ns__ServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:275 */
#ifndef SOAP_TYPE_ns__CityLocation
#define SOAP_TYPE_ns__CityLocation (56)
/* ns:CityLocation complex type: */
class SOAP_CMAC ns__CityLocation
{
public:
	std::string cityLocationCityName;	/* optional element of XSD type xsd:string */
	std::vector<std::string> cityLocationLocationsName;	/* optional element of XSD type xsd:string */
	ns__ErrorCode cityLocationError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__CityLocation (56)
	virtual int soap_type(void) const { return 56; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__CityLocation, default initialized and not managed by a soap context
	virtual ns__CityLocation *soap_alloc(void) const { return SOAP_NEW(ns__CityLocation); }
	         ns__CityLocation() { ns__CityLocation::soap_default(NULL); }
	virtual ~ns__CityLocation() { }
	friend ns__CityLocation *soap_instantiate_ns__CityLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:282 */
#ifndef SOAP_TYPE_ns__AllCityLocatoins
#define SOAP_TYPE_ns__AllCityLocatoins (58)
/* ns:AllCityLocatoins complex type: */
class SOAP_CMAC ns__AllCityLocatoins
{
public:
	std::vector<ns__CityLocation> allCityLocatoins;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns:CityLocation */
	ns__ErrorCode allCityLocatoinsError;	/* required element of XSD type ns:ErrorCode */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__AllCityLocatoins (58)
	virtual int soap_type(void) const { return 58; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns__AllCityLocatoins, default initialized and not managed by a soap context
	virtual ns__AllCityLocatoins *soap_alloc(void) const { return SOAP_NEW(ns__AllCityLocatoins); }
	         ns__AllCityLocatoins() { ns__AllCityLocatoins::soap_default(NULL); }
	virtual ~ns__AllCityLocatoins() { }
	friend ns__AllCityLocatoins *soap_instantiate_ns__AllCityLocatoins(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:288 */
#ifndef SOAP_TYPE_ns__GetDeviceStatus
#define SOAP_TYPE_ns__GetDeviceStatus (62)
/* ns:GetDeviceStatus complex type: */
struct ns__GetDeviceStatus
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__Device requestDeviceInfo;	/* required element of XSD type ns:Device */
public:
	int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_ns__GetDeviceStatus */
	         ns__GetDeviceStatus();
	virtual ~ns__GetDeviceStatus() { }
	friend ns__GetDeviceStatus *soap_instantiate_ns__GetDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:289 */
#ifndef SOAP_TYPE_ns__GetAllDeviceStatus
#define SOAP_TYPE_ns__GetAllDeviceStatus (65)
/* ns:GetAllDeviceStatus complex type: */
struct ns__GetAllDeviceStatus
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_ns__GetAllDeviceStatus */
	         ns__GetAllDeviceStatus();
	virtual ~ns__GetAllDeviceStatus() { }
	friend ns__GetAllDeviceStatus *soap_instantiate_ns__GetAllDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:290 */
#ifndef SOAP_TYPE_ns__SetDeviceSetting
#define SOAP_TYPE_ns__SetDeviceSetting (68)
/* ns:SetDeviceSetting complex type: */
struct ns__SetDeviceSetting
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__Device requestDeviceInfo;	/* required element of XSD type ns:Device */
public:
	int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_ns__SetDeviceSetting */
	         ns__SetDeviceSetting();
	virtual ~ns__SetDeviceSetting() { }
	friend ns__SetDeviceSetting *soap_instantiate_ns__SetDeviceSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:291 */
#ifndef SOAP_TYPE_ns__SetAllDeviceSettingResponse
#define SOAP_TYPE_ns__SetAllDeviceSettingResponse (72)
/* ns:SetAllDeviceSettingResponse complex type: */
struct ns__SetAllDeviceSettingResponse
{
public:
	std::vector<ns__ErrorCode> responseErrorInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns:ErrorCode */
public:
	int soap_type() const { return 72; } /* = unique type id SOAP_TYPE_ns__SetAllDeviceSettingResponse */
	         ns__SetAllDeviceSettingResponse();
	virtual ~ns__SetAllDeviceSettingResponse() { }
	friend ns__SetAllDeviceSettingResponse *soap_instantiate_ns__SetAllDeviceSettingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:291 */
#ifndef SOAP_TYPE_ns__SetAllDeviceSetting
#define SOAP_TYPE_ns__SetAllDeviceSetting (73)
/* ns:SetAllDeviceSetting complex type: */
struct ns__SetAllDeviceSetting
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	std::vector<ns__Device> requestDeviceInfo;	/* required element of XSD type ns:Device */
public:
	int soap_type() const { return 73; } /* = unique type id SOAP_TYPE_ns__SetAllDeviceSetting */
	         ns__SetAllDeviceSetting();
	virtual ~ns__SetAllDeviceSetting() { }
	friend ns__SetAllDeviceSetting *soap_instantiate_ns__SetAllDeviceSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:292 */
#ifndef SOAP_TYPE_ns__DeleteDevices
#define SOAP_TYPE_ns__DeleteDevices (75)
/* ns:DeleteDevices complex type: */
struct ns__DeleteDevices
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	std::vector<ns__Device> requestDeviceList;	/* required element of XSD type ns:Device */
public:
	int soap_type() const { return 75; } /* = unique type id SOAP_TYPE_ns__DeleteDevices */
	         ns__DeleteDevices();
	virtual ~ns__DeleteDevices() { }
	friend ns__DeleteDevices *soap_instantiate_ns__DeleteDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:294 */
#ifndef SOAP_TYPE_ns__Login
#define SOAP_TYPE_ns__Login (78)
/* ns:Login complex type: */
struct ns__Login
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 78; } /* = unique type id SOAP_TYPE_ns__Login */
	         ns__Login();
	virtual ~ns__Login() { }
	friend ns__Login *soap_instantiate_ns__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:295 */
#ifndef SOAP_TYPE_ns__GetUserDeviceList
#define SOAP_TYPE_ns__GetUserDeviceList (80)
/* ns:GetUserDeviceList complex type: */
struct ns__GetUserDeviceList
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 80; } /* = unique type id SOAP_TYPE_ns__GetUserDeviceList */
	         ns__GetUserDeviceList();
	virtual ~ns__GetUserDeviceList() { }
	friend ns__GetUserDeviceList *soap_instantiate_ns__GetUserDeviceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:296 */
#ifndef SOAP_TYPE_ns__GetAllDeviceList
#define SOAP_TYPE_ns__GetAllDeviceList (82)
/* ns:GetAllDeviceList complex type: */
struct ns__GetAllDeviceList
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 82; } /* = unique type id SOAP_TYPE_ns__GetAllDeviceList */
	         ns__GetAllDeviceList();
	virtual ~ns__GetAllDeviceList() { }
	friend ns__GetAllDeviceList *soap_instantiate_ns__GetAllDeviceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:298 */
#ifndef SOAP_TYPE_ns__GetUsersList
#define SOAP_TYPE_ns__GetUsersList (85)
/* ns:GetUsersList complex type: */
struct ns__GetUsersList
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 85; } /* = unique type id SOAP_TYPE_ns__GetUsersList */
	         ns__GetUsersList();
	virtual ~ns__GetUsersList() { }
	friend ns__GetUsersList *soap_instantiate_ns__GetUsersList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:299 */
#ifndef SOAP_TYPE_ns__AddUser
#define SOAP_TYPE_ns__AddUser (87)
/* ns:AddUser complex type: */
struct ns__AddUser
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__User requestNewUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE_ns__AddUser */
	         ns__AddUser();
	virtual ~ns__AddUser() { }
	friend ns__AddUser *soap_instantiate_ns__AddUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:300 */
#ifndef SOAP_TYPE_ns__UpdateUser
#define SOAP_TYPE_ns__UpdateUser (89)
/* ns:UpdateUser complex type: */
struct ns__UpdateUser
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__User requestNewUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 89; } /* = unique type id SOAP_TYPE_ns__UpdateUser */
	         ns__UpdateUser();
	virtual ~ns__UpdateUser() { }
	friend ns__UpdateUser *soap_instantiate_ns__UpdateUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:301 */
#ifndef SOAP_TYPE_ns__DeleteUser
#define SOAP_TYPE_ns__DeleteUser (91)
/* ns:DeleteUser complex type: */
struct ns__DeleteUser
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__User requestDeleteUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 91; } /* = unique type id SOAP_TYPE_ns__DeleteUser */
	         ns__DeleteUser();
	virtual ~ns__DeleteUser() { }
	friend ns__DeleteUser *soap_instantiate_ns__DeleteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:302 */
#ifndef SOAP_TYPE_ns__AssignDeviceToUser
#define SOAP_TYPE_ns__AssignDeviceToUser (93)
/* ns:AssignDeviceToUser complex type: */
struct ns__AssignDeviceToUser
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__UserDevice requestUserDeviceInfo;	/* required element of XSD type ns:UserDevice */
public:
	int soap_type() const { return 93; } /* = unique type id SOAP_TYPE_ns__AssignDeviceToUser */
	         ns__AssignDeviceToUser();
	virtual ~ns__AssignDeviceToUser() { }
	friend ns__AssignDeviceToUser *soap_instantiate_ns__AssignDeviceToUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:303 */
#ifndef SOAP_TYPE_ns__DeleteDeviceFromUserList
#define SOAP_TYPE_ns__DeleteDeviceFromUserList (95)
/* ns:DeleteDeviceFromUserList complex type: */
struct ns__DeleteDeviceFromUserList
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__UserDevice requestUserDeviceInfo;	/* required element of XSD type ns:UserDevice */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE_ns__DeleteDeviceFromUserList */
	         ns__DeleteDeviceFromUserList();
	virtual ~ns__DeleteDeviceFromUserList() { }
	friend ns__DeleteDeviceFromUserList *soap_instantiate_ns__DeleteDeviceFromUserList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:304 */
#ifndef SOAP_TYPE_ns__GetUserDevices
#define SOAP_TYPE_ns__GetUserDevices (97)
/* ns:GetUserDevices complex type: */
struct ns__GetUserDevices
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__User requestSelectedUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 97; } /* = unique type id SOAP_TYPE_ns__GetUserDevices */
	         ns__GetUserDevices();
	virtual ~ns__GetUserDevices() { }
	friend ns__GetUserDevices *soap_instantiate_ns__GetUserDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:306 */
#ifndef SOAP_TYPE_ns__SaveActivityLog
#define SOAP_TYPE_ns__SaveActivityLog (99)
/* ns:SaveActivityLog complex type: */
struct ns__SaveActivityLog
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__ActivityLog requestActivityLogInfo;	/* required element of XSD type ns:ActivityLog */
public:
	int soap_type() const { return 99; } /* = unique type id SOAP_TYPE_ns__SaveActivityLog */
	         ns__SaveActivityLog();
	virtual ~ns__SaveActivityLog() { }
	friend ns__SaveActivityLog *soap_instantiate_ns__SaveActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:307 */
#ifndef SOAP_TYPE_ns__GetActivityLogResponse
#define SOAP_TYPE_ns__GetActivityLogResponse (103)
/* ns:GetActivityLogResponse complex type: */
struct ns__GetActivityLogResponse
{
public:
	std::vector<ns__ActivityLog> responseActivityLogInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns:ActivityLog */
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE_ns__GetActivityLogResponse */
	         ns__GetActivityLogResponse();
	virtual ~ns__GetActivityLogResponse() { }
	friend ns__GetActivityLogResponse *soap_instantiate_ns__GetActivityLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:307 */
#ifndef SOAP_TYPE_ns__GetActivityLog
#define SOAP_TYPE_ns__GetActivityLog (104)
/* ns:GetActivityLog complex type: */
struct ns__GetActivityLog
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__Report requestReportInfo;	/* required element of XSD type ns:Report */
public:
	int soap_type() const { return 104; } /* = unique type id SOAP_TYPE_ns__GetActivityLog */
	         ns__GetActivityLog();
	virtual ~ns__GetActivityLog() { }
	friend ns__GetActivityLog *soap_instantiate_ns__GetActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:308 */
#ifndef SOAP_TYPE_ns__SaveUserLog
#define SOAP_TYPE_ns__SaveUserLog (106)
/* ns:SaveUserLog complex type: */
struct ns__SaveUserLog
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__UserLog requestActivityLogInfo;	/* required element of XSD type ns:UserLog */
public:
	int soap_type() const { return 106; } /* = unique type id SOAP_TYPE_ns__SaveUserLog */
	         ns__SaveUserLog();
	virtual ~ns__SaveUserLog() { }
	friend ns__SaveUserLog *soap_instantiate_ns__SaveUserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:309 */
#ifndef SOAP_TYPE_ns__GetUserLogResponse
#define SOAP_TYPE_ns__GetUserLogResponse (110)
/* ns:GetUserLogResponse complex type: */
struct ns__GetUserLogResponse
{
public:
	std::vector<ns__UserLog> responseActivityLogInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns:UserLog */
public:
	int soap_type() const { return 110; } /* = unique type id SOAP_TYPE_ns__GetUserLogResponse */
	         ns__GetUserLogResponse();
	virtual ~ns__GetUserLogResponse() { }
	friend ns__GetUserLogResponse *soap_instantiate_ns__GetUserLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:309 */
#ifndef SOAP_TYPE_ns__GetUserLog
#define SOAP_TYPE_ns__GetUserLog (111)
/* ns:GetUserLog complex type: */
struct ns__GetUserLog
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__Report requestReportInfo;	/* required element of XSD type ns:Report */
public:
	int soap_type() const { return 111; } /* = unique type id SOAP_TYPE_ns__GetUserLog */
	         ns__GetUserLog();
	virtual ~ns__GetUserLog() { }
	friend ns__GetUserLog *soap_instantiate_ns__GetUserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:310 */
#ifndef SOAP_TYPE_ns__SaveDeviceStatusLog
#define SOAP_TYPE_ns__SaveDeviceStatusLog (113)
/* ns:SaveDeviceStatusLog complex type: */
struct ns__SaveDeviceStatusLog
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__DeviceStatusLog requestStatusLogInfo;	/* required element of XSD type ns:DeviceStatusLog */
public:
	int soap_type() const { return 113; } /* = unique type id SOAP_TYPE_ns__SaveDeviceStatusLog */
	         ns__SaveDeviceStatusLog();
	virtual ~ns__SaveDeviceStatusLog() { }
	friend ns__SaveDeviceStatusLog *soap_instantiate_ns__SaveDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:311 */
#ifndef SOAP_TYPE_ns__GetDeviceStatusLog
#define SOAP_TYPE_ns__GetDeviceStatusLog (116)
/* ns:GetDeviceStatusLog complex type: */
struct ns__GetDeviceStatusLog
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__DeviceStatusInfo requestStatusLogInfo;	/* required element of XSD type ns:DeviceStatusInfo */
public:
	int soap_type() const { return 116; } /* = unique type id SOAP_TYPE_ns__GetDeviceStatusLog */
	         ns__GetDeviceStatusLog();
	virtual ~ns__GetDeviceStatusLog() { }
	friend ns__GetDeviceStatusLog *soap_instantiate_ns__GetDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:313 */
#ifndef SOAP_TYPE_ns__GetServerOptions
#define SOAP_TYPE_ns__GetServerOptions (119)
/* ns:GetServerOptions complex type: */
struct ns__GetServerOptions
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 119; } /* = unique type id SOAP_TYPE_ns__GetServerOptions */
	         ns__GetServerOptions();
	virtual ~ns__GetServerOptions() { }
	friend ns__GetServerOptions *soap_instantiate_ns__GetServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:314 */
#ifndef SOAP_TYPE_ns__SetServerOptions
#define SOAP_TYPE_ns__SetServerOptions (121)
/* ns:SetServerOptions complex type: */
struct ns__SetServerOptions
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	ns__ServerOptions serverOptions;	/* required element of XSD type ns:ServerOptions */
public:
	int soap_type() const { return 121; } /* = unique type id SOAP_TYPE_ns__SetServerOptions */
	         ns__SetServerOptions();
	virtual ~ns__SetServerOptions() { }
	friend ns__SetServerOptions *soap_instantiate_ns__SetServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:316 */
#ifndef SOAP_TYPE_ns__GetCityAndLocations
#define SOAP_TYPE_ns__GetCityAndLocations (124)
/* ns:GetCityAndLocations complex type: */
struct ns__GetCityAndLocations
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
public:
	int soap_type() const { return 124; } /* = unique type id SOAP_TYPE_ns__GetCityAndLocations */
	         ns__GetCityAndLocations();
	virtual ~ns__GetCityAndLocations() { }
	friend ns__GetCityAndLocations *soap_instantiate_ns__GetCityAndLocations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:317 */
#ifndef SOAP_TYPE_ns__ChangeCityName
#define SOAP_TYPE_ns__ChangeCityName (126)
/* ns:ChangeCityName complex type: */
struct ns__ChangeCityName
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	std::string oldCityName;	/* required element of XSD type xsd:string */
	std::string newCityName;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 126; } /* = unique type id SOAP_TYPE_ns__ChangeCityName */
	         ns__ChangeCityName();
	virtual ~ns__ChangeCityName() { }
	friend ns__ChangeCityName *soap_instantiate_ns__ChangeCityName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:318 */
#ifndef SOAP_TYPE_ns__ChangeLocationName
#define SOAP_TYPE_ns__ChangeLocationName (128)
/* ns:ChangeLocationName complex type: */
struct ns__ChangeLocationName
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	std::string oldCityName;	/* required element of XSD type xsd:string */
	std::string newCityName;	/* required element of XSD type xsd:string */
	std::string oldLocationName;	/* required element of XSD type xsd:string */
	std::string newLocationName;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 128; } /* = unique type id SOAP_TYPE_ns__ChangeLocationName */
	         ns__ChangeLocationName();
	virtual ~ns__ChangeLocationName() { }
	friend ns__ChangeLocationName *soap_instantiate_ns__ChangeLocationName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:319 */
#ifndef SOAP_TYPE_ns__ChangeDeviceName
#define SOAP_TYPE_ns__ChangeDeviceName (130)
/* ns:ChangeDeviceName complex type: */
struct ns__ChangeDeviceName
{
public:
	ns__User requestUserInfo;	/* required element of XSD type ns:User */
	int deviceSerialNumber;	/* required element of XSD type xsd:int */
	std::string newCityName;	/* required element of XSD type xsd:string */
	std::string newLocationName;	/* required element of XSD type xsd:string */
	std::string newDeviceName;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 130; } /* = unique type id SOAP_TYPE_ns__ChangeDeviceName */
	         ns__ChangeDeviceName();
	virtual ~ns__ChangeDeviceName() { }
	friend ns__ChangeDeviceName *soap_instantiate_ns__ChangeDeviceName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
#ifndef SOAP_TYPE_ns__TestWorldResponse
#define SOAP_TYPE_ns__TestWorldResponse (133)
/* ns:TestWorldResponse complex type: */
struct ns__TestWorldResponse
{
public:
	struct tm responseErrorInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* external (custom serializer) */
public:
	int soap_type() const { return 133; } /* = unique type id SOAP_TYPE_ns__TestWorldResponse */
	         ns__TestWorldResponse();
	virtual ~ns__TestWorldResponse() { }
	friend ns__TestWorldResponse *soap_instantiate_ns__TestWorldResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
#ifndef SOAP_TYPE_ns__TestWorld
#define SOAP_TYPE_ns__TestWorld (134)
/* ns:TestWorld complex type: */
struct ns__TestWorld
{
public:
	struct tm requestUserInfo;	/* external (custom serializer) */
public:
	int soap_type() const { return 134; } /* = unique type id SOAP_TYPE_ns__TestWorld */
	         ns__TestWorld();
	virtual ~ns__TestWorld() { }
	friend ns__TestWorld *soap_instantiate_ns__TestWorld(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (135)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 135; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	virtual ~SOAP_ENV__Header() { }
	friend SOAP_ENV__Header *soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (136)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 136; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	virtual ~SOAP_ENV__Code() { }
	friend SOAP_ENV__Code *soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (138)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 138; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	virtual ~SOAP_ENV__Detail() { }
	friend SOAP_ENV__Detail *soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (141)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 141; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	virtual ~SOAP_ENV__Reason() { }
	friend SOAP_ENV__Reason *soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:321 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (142)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 142; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	virtual ~SOAP_ENV__Fault() { }
	friend SOAP_ENV__Fault *soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* stlvector.h:53 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* stlvector.h:53 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:67 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (16)
typedef std::string xsd__string;
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:68 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (17)
typedef int xsd__int;
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:69 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (19)
typedef bool xsd__boolean;
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:70 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (21)
typedef double xsd__double;
#endif

/* F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h:72 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (25)
typedef LONG64 xsd__long;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceStatus(struct soap*, ns__User requestUserInfo, ns__Device requestDeviceInfo, ns__Device &responseDeviceInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllDeviceStatus(struct soap*, ns__User requestUserInfo, ns__UserDevice &responseUserDevicesInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetDeviceSetting(struct soap*, ns__User requestUserInfo, ns__Device requestDeviceInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetAllDeviceSetting(struct soap*, ns__User requestUserInfo, std::vector<ns__Device> requestDeviceInfo, std::vector<ns__ErrorCode> &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteDevices(struct soap*, ns__User requestUserInfo, std::vector<ns__Device> requestDeviceList, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__Login(struct soap*, ns__User requestUserInfo, ns__User &responseUserInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserDeviceList(struct soap*, ns__User requestUserInfo, ns__UserDevice &responseUserDevicesInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllDeviceList(struct soap*, ns__User requestUserInfo, ns__UserDevice &responseUserDevicesInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetUsersList(struct soap*, ns__User requestUserInfo, ns__UsersList &responseUsersList);

SOAP_FMAC5 int SOAP_FMAC6 ns__AddUser(struct soap*, ns__User requestUserInfo, ns__User requestNewUserInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__UpdateUser(struct soap*, ns__User requestUserInfo, ns__User requestNewUserInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteUser(struct soap*, ns__User requestUserInfo, ns__User requestDeleteUserInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__AssignDeviceToUser(struct soap*, ns__User requestUserInfo, ns__UserDevice requestUserDeviceInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteDeviceFromUserList(struct soap*, ns__User requestUserInfo, ns__UserDevice requestUserDeviceInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserDevices(struct soap*, ns__User requestUserInfo, ns__User requestSelectedUserInfo, ns__UserDevice &responseUserDevicesInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__SaveActivityLog(struct soap*, ns__User requestUserInfo, ns__ActivityLog requestActivityLogInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetActivityLog(struct soap*, ns__User requestUserInfo, ns__Report requestReportInfo, std::vector<ns__ActivityLog> &responseActivityLogInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__SaveUserLog(struct soap*, ns__User requestUserInfo, ns__UserLog requestActivityLogInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserLog(struct soap*, ns__User requestUserInfo, ns__Report requestReportInfo, std::vector<ns__UserLog> &responseActivityLogInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__SaveDeviceStatusLog(struct soap*, ns__User requestUserInfo, ns__DeviceStatusLog requestStatusLogInfo, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceStatusLog(struct soap*, ns__User requestUserInfo, ns__DeviceStatusInfo requestStatusLogInfo, ns__DeviceStatusLogList &responseStatusLogList);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetServerOptions(struct soap*, ns__User requestUserInfo, ns__ServerOptions &serverOptions);

SOAP_FMAC5 int SOAP_FMAC6 ns__SetServerOptions(struct soap*, ns__User requestUserInfo, ns__ServerOptions serverOptions, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__GetCityAndLocations(struct soap*, ns__User requestUserInfo, ns__AllCityLocatoins &responseCityLocationInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeCityName(struct soap*, ns__User requestUserInfo, std::string oldCityName, std::string newCityName, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeLocationName(struct soap*, ns__User requestUserInfo, std::string oldCityName, std::string newCityName, std::string oldLocationName, std::string newLocationName, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeDeviceName(struct soap*, ns__User requestUserInfo, int deviceSerialNumber, std::string newCityName, std::string newLocationName, std::string newDeviceName, ns__ErrorCode &responseErrorInfo);

SOAP_FMAC5 int SOAP_FMAC6 ns__TestWorld(struct soap*, struct tm requestUserInfo, struct tm &responseErrorInfo);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllDeviceStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetDeviceSetting(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetAllDeviceSetting(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteDevices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__Login(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserDeviceList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllDeviceList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUsersList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__AddUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__UpdateUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__AssignDeviceToUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteDeviceFromUserList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserDevices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveActivityLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetActivityLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveUserLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveDeviceStatusLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceStatusLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetServerOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetServerOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetCityAndLocations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeCityName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeLocationName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeDeviceName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__TestWorld(struct soap*);

#endif

/* End of Server_SoapStub.h */
