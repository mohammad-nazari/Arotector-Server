/* Server_SoapC.cpp
   Generated by gSOAP 2.8.27 from F:\Projects\WebService\GeneratedCode\Protector\source\WebService\Protector.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "Server_SoapH.h"

SOAP_SOURCE_STAMP("@(#) Server_SoapC.cpp ver 2.8.27 2016-03-29 20:01:15 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns__SensorName:
		return soap_in_ns__SensorName(soap, NULL, NULL, "ns:SensorName");
	case SOAP_TYPE_ns__SensorType:
		return soap_in_ns__SensorType(soap, NULL, NULL, "ns:SensorType");
	case SOAP_TYPE_ns__SimcardType:
		return soap_in_ns__SimcardType(soap, NULL, NULL, "ns:SimcardType");
	case SOAP_TYPE_ns__UserType:
		return soap_in_ns__UserType(soap, NULL, NULL, "ns:UserType");
	case SOAP_TYPE_ns__SettingLevel:
		return soap_in_ns__SettingLevel(soap, NULL, NULL, "ns:SettingLevel");
	case SOAP_TYPE_ns__AllCityLocatoins:
		return soap_in_ns__AllCityLocatoins(soap, NULL, NULL, "ns:AllCityLocatoins");
	case SOAP_TYPE_ns__CityLocation:
		return soap_in_ns__CityLocation(soap, NULL, NULL, "ns:CityLocation");
	case SOAP_TYPE_ns__ServerOptions:
		return soap_in_ns__ServerOptions(soap, NULL, NULL, "ns:ServerOptions");
	case SOAP_TYPE_ns__DataBaseInfo:
		return soap_in_ns__DataBaseInfo(soap, NULL, NULL, "ns:DataBaseInfo");
	case SOAP_TYPE_ns__UserDevice:
		return soap_in_ns__UserDevice(soap, NULL, NULL, "ns:UserDevice");
	case SOAP_TYPE_ns__UserDevices:
		return soap_in_ns__UserDevices(soap, NULL, NULL, "ns:UserDevices");
	case SOAP_TYPE_ns__DeviceRules:
		return soap_in_ns__DeviceRules(soap, NULL, NULL, "ns:DeviceRules");
	case SOAP_TYPE_ns__ErrorLog:
		return soap_in_ns__ErrorLog(soap, NULL, NULL, "ns:ErrorLog");
	case SOAP_TYPE_ns__DeviceStatusInfo:
		return soap_in_ns__DeviceStatusInfo(soap, NULL, NULL, "ns:DeviceStatusInfo");
	case SOAP_TYPE_ns__DeviceStatusLogList:
		return soap_in_ns__DeviceStatusLogList(soap, NULL, NULL, "ns:DeviceStatusLogList");
	case SOAP_TYPE_ns__DeviceStatusLog:
		return soap_in_ns__DeviceStatusLog(soap, NULL, NULL, "ns:DeviceStatusLog");
	case SOAP_TYPE_ns__UserLog:
		return soap_in_ns__UserLog(soap, NULL, NULL, "ns:UserLog");
	case SOAP_TYPE_ns__ActivityLog:
		return soap_in_ns__ActivityLog(soap, NULL, NULL, "ns:ActivityLog");
	case SOAP_TYPE_ns__Report:
		return soap_in_ns__Report(soap, NULL, NULL, "ns:Report");
	case SOAP_TYPE_ns__Device:
		return soap_in_ns__Device(soap, NULL, NULL, "ns:Device");
	case SOAP_TYPE_ns__Sensor:
		return soap_in_ns__Sensor(soap, NULL, NULL, "ns:Sensor");
	case SOAP_TYPE_ns__Relay:
		return soap_in_ns__Relay(soap, NULL, NULL, "ns:Relay");
	case SOAP_TYPE_ns__Mobile:
		return soap_in_ns__Mobile(soap, NULL, NULL, "ns:Mobile");
	case SOAP_TYPE_ns__Gprs:
		return soap_in_ns__Gprs(soap, NULL, NULL, "ns:Gprs");
	case SOAP_TYPE_ns__Server:
		return soap_in_ns__Server(soap, NULL, NULL, "ns:Server");
	case SOAP_TYPE_ns__IP:
		return soap_in_ns__IP(soap, NULL, NULL, "ns:IP");
	case SOAP_TYPE_ns__UsersList:
		return soap_in_ns__UsersList(soap, NULL, NULL, "ns:UsersList");
	case SOAP_TYPE_ns__User:
		return soap_in_ns__User(soap, NULL, NULL, "ns:User");
	case SOAP_TYPE_ns__ErrorCode:
		return soap_in_ns__ErrorCode(soap, NULL, NULL, "ns:ErrorCode");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns__TestWorld:
		return soap_in_ns__TestWorld(soap, NULL, NULL, "ns:TestWorld");
	case SOAP_TYPE_ns__TestWorldResponse:
		return soap_in_ns__TestWorldResponse(soap, NULL, NULL, "ns:TestWorldResponse");
	case SOAP_TYPE_ns__ChangeDeviceName:
		return soap_in_ns__ChangeDeviceName(soap, NULL, NULL, "ns:ChangeDeviceName");
	case SOAP_TYPE_ns__ChangeLocationName:
		return soap_in_ns__ChangeLocationName(soap, NULL, NULL, "ns:ChangeLocationName");
	case SOAP_TYPE_ns__ChangeCityName:
		return soap_in_ns__ChangeCityName(soap, NULL, NULL, "ns:ChangeCityName");
	case SOAP_TYPE_ns__GetCityAndLocations:
		return soap_in_ns__GetCityAndLocations(soap, NULL, NULL, "ns:GetCityAndLocations");
	case SOAP_TYPE_ns__SetServerOptions:
		return soap_in_ns__SetServerOptions(soap, NULL, NULL, "ns:SetServerOptions");
	case SOAP_TYPE_ns__GetServerOptions:
		return soap_in_ns__GetServerOptions(soap, NULL, NULL, "ns:GetServerOptions");
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		return soap_in_ns__GetDeviceStatusLog(soap, NULL, NULL, "ns:GetDeviceStatusLog");
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		return soap_in_ns__SaveDeviceStatusLog(soap, NULL, NULL, "ns:SaveDeviceStatusLog");
	case SOAP_TYPE_ns__GetUserLog:
		return soap_in_ns__GetUserLog(soap, NULL, NULL, "ns:GetUserLog");
	case SOAP_TYPE_ns__GetUserLogResponse:
		return soap_in_ns__GetUserLogResponse(soap, NULL, NULL, "ns:GetUserLogResponse");
	case SOAP_TYPE_ns__SaveUserLog:
		return soap_in_ns__SaveUserLog(soap, NULL, NULL, "ns:SaveUserLog");
	case SOAP_TYPE_ns__GetActivityLog:
		return soap_in_ns__GetActivityLog(soap, NULL, NULL, "ns:GetActivityLog");
	case SOAP_TYPE_ns__GetActivityLogResponse:
		return soap_in_ns__GetActivityLogResponse(soap, NULL, NULL, "ns:GetActivityLogResponse");
	case SOAP_TYPE_ns__SaveActivityLog:
		return soap_in_ns__SaveActivityLog(soap, NULL, NULL, "ns:SaveActivityLog");
	case SOAP_TYPE_ns__GetUserDevices:
		return soap_in_ns__GetUserDevices(soap, NULL, NULL, "ns:GetUserDevices");
	case SOAP_TYPE_ns__DeleteDeviceFromUserList:
		return soap_in_ns__DeleteDeviceFromUserList(soap, NULL, NULL, "ns:DeleteDeviceFromUserList");
	case SOAP_TYPE_ns__AssignDeviceToUser:
		return soap_in_ns__AssignDeviceToUser(soap, NULL, NULL, "ns:AssignDeviceToUser");
	case SOAP_TYPE_ns__DeleteUser:
		return soap_in_ns__DeleteUser(soap, NULL, NULL, "ns:DeleteUser");
	case SOAP_TYPE_ns__UpdateUser:
		return soap_in_ns__UpdateUser(soap, NULL, NULL, "ns:UpdateUser");
	case SOAP_TYPE_ns__AddUser:
		return soap_in_ns__AddUser(soap, NULL, NULL, "ns:AddUser");
	case SOAP_TYPE_ns__GetUsersList:
		return soap_in_ns__GetUsersList(soap, NULL, NULL, "ns:GetUsersList");
	case SOAP_TYPE_ns__GetAllDeviceList:
		return soap_in_ns__GetAllDeviceList(soap, NULL, NULL, "ns:GetAllDeviceList");
	case SOAP_TYPE_ns__GetUserDeviceList:
		return soap_in_ns__GetUserDeviceList(soap, NULL, NULL, "ns:GetUserDeviceList");
	case SOAP_TYPE_ns__Login:
		return soap_in_ns__Login(soap, NULL, NULL, "ns:Login");
	case SOAP_TYPE_ns__DeleteDevices:
		return soap_in_ns__DeleteDevices(soap, NULL, NULL, "ns:DeleteDevices");
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		return soap_in_ns__SetAllDeviceSetting(soap, NULL, NULL, "ns:SetAllDeviceSetting");
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		return soap_in_ns__SetAllDeviceSettingResponse(soap, NULL, NULL, "ns:SetAllDeviceSettingResponse");
	case SOAP_TYPE_ns__SetDeviceSetting:
		return soap_in_ns__SetDeviceSetting(soap, NULL, NULL, "ns:SetDeviceSetting");
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		return soap_in_ns__GetAllDeviceStatus(soap, NULL, NULL, "ns:GetAllDeviceStatus");
	case SOAP_TYPE_ns__GetDeviceStatus:
		return soap_in_ns__GetDeviceStatus(soap, NULL, NULL, "ns:GetDeviceStatus");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_tm:
		return soap_in_tm(soap, NULL, NULL, "tm");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns:AllCityLocatoins"))
		{	*type = SOAP_TYPE_ns__AllCityLocatoins;
			return soap_in_ns__AllCityLocatoins(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:CityLocation"))
		{	*type = SOAP_TYPE_ns__CityLocation;
			return soap_in_ns__CityLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ServerOptions"))
		{	*type = SOAP_TYPE_ns__ServerOptions;
			return soap_in_ns__ServerOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DataBaseInfo"))
		{	*type = SOAP_TYPE_ns__DataBaseInfo;
			return soap_in_ns__DataBaseInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserDevice"))
		{	*type = SOAP_TYPE_ns__UserDevice;
			return soap_in_ns__UserDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserDevices"))
		{	*type = SOAP_TYPE_ns__UserDevices;
			return soap_in_ns__UserDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceRules"))
		{	*type = SOAP_TYPE_ns__DeviceRules;
			return soap_in_ns__DeviceRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ErrorLog"))
		{	*type = SOAP_TYPE_ns__ErrorLog;
			return soap_in_ns__ErrorLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceStatusInfo"))
		{	*type = SOAP_TYPE_ns__DeviceStatusInfo;
			return soap_in_ns__DeviceStatusInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceStatusLogList"))
		{	*type = SOAP_TYPE_ns__DeviceStatusLogList;
			return soap_in_ns__DeviceStatusLogList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceStatusLog"))
		{	*type = SOAP_TYPE_ns__DeviceStatusLog;
			return soap_in_ns__DeviceStatusLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserLog"))
		{	*type = SOAP_TYPE_ns__UserLog;
			return soap_in_ns__UserLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ActivityLog"))
		{	*type = SOAP_TYPE_ns__ActivityLog;
			return soap_in_ns__ActivityLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Report"))
		{	*type = SOAP_TYPE_ns__Report;
			return soap_in_ns__Report(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Device"))
		{	*type = SOAP_TYPE_ns__Device;
			return soap_in_ns__Device(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Sensor"))
		{	*type = SOAP_TYPE_ns__Sensor;
			return soap_in_ns__Sensor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Relay"))
		{	*type = SOAP_TYPE_ns__Relay;
			return soap_in_ns__Relay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Mobile"))
		{	*type = SOAP_TYPE_ns__Mobile;
			return soap_in_ns__Mobile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Gprs"))
		{	*type = SOAP_TYPE_ns__Gprs;
			return soap_in_ns__Gprs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Server"))
		{	*type = SOAP_TYPE_ns__Server;
			return soap_in_ns__Server(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:IP"))
		{	*type = SOAP_TYPE_ns__IP;
			return soap_in_ns__IP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UsersList"))
		{	*type = SOAP_TYPE_ns__UsersList;
			return soap_in_ns__UsersList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:User"))
		{	*type = SOAP_TYPE_ns__User;
			return soap_in_ns__User(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ErrorCode"))
		{	*type = SOAP_TYPE_ns__ErrorCode;
			return soap_in_ns__ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SensorName"))
		{	*type = SOAP_TYPE_ns__SensorName;
			return soap_in_ns__SensorName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SensorType"))
		{	*type = SOAP_TYPE_ns__SensorType;
			return soap_in_ns__SensorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SimcardType"))
		{	*type = SOAP_TYPE_ns__SimcardType;
			return soap_in_ns__SimcardType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserType"))
		{	*type = SOAP_TYPE_ns__UserType;
			return soap_in_ns__UserType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SettingLevel"))
		{	*type = SOAP_TYPE_ns__SettingLevel;
			return soap_in_ns__SettingLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:TestWorld"))
		{	*type = SOAP_TYPE_ns__TestWorld;
			return soap_in_ns__TestWorld(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:TestWorldResponse"))
		{	*type = SOAP_TYPE_ns__TestWorldResponse;
			return soap_in_ns__TestWorldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ChangeDeviceName"))
		{	*type = SOAP_TYPE_ns__ChangeDeviceName;
			return soap_in_ns__ChangeDeviceName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ChangeLocationName"))
		{	*type = SOAP_TYPE_ns__ChangeLocationName;
			return soap_in_ns__ChangeLocationName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ChangeCityName"))
		{	*type = SOAP_TYPE_ns__ChangeCityName;
			return soap_in_ns__ChangeCityName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetCityAndLocations"))
		{	*type = SOAP_TYPE_ns__GetCityAndLocations;
			return soap_in_ns__GetCityAndLocations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetServerOptions"))
		{	*type = SOAP_TYPE_ns__SetServerOptions;
			return soap_in_ns__SetServerOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetServerOptions"))
		{	*type = SOAP_TYPE_ns__GetServerOptions;
			return soap_in_ns__GetServerOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDeviceStatusLog"))
		{	*type = SOAP_TYPE_ns__GetDeviceStatusLog;
			return soap_in_ns__GetDeviceStatusLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SaveDeviceStatusLog"))
		{	*type = SOAP_TYPE_ns__SaveDeviceStatusLog;
			return soap_in_ns__SaveDeviceStatusLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserLog"))
		{	*type = SOAP_TYPE_ns__GetUserLog;
			return soap_in_ns__GetUserLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserLogResponse"))
		{	*type = SOAP_TYPE_ns__GetUserLogResponse;
			return soap_in_ns__GetUserLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SaveUserLog"))
		{	*type = SOAP_TYPE_ns__SaveUserLog;
			return soap_in_ns__SaveUserLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetActivityLog"))
		{	*type = SOAP_TYPE_ns__GetActivityLog;
			return soap_in_ns__GetActivityLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetActivityLogResponse"))
		{	*type = SOAP_TYPE_ns__GetActivityLogResponse;
			return soap_in_ns__GetActivityLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SaveActivityLog"))
		{	*type = SOAP_TYPE_ns__SaveActivityLog;
			return soap_in_ns__SaveActivityLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserDevices"))
		{	*type = SOAP_TYPE_ns__GetUserDevices;
			return soap_in_ns__GetUserDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeleteDeviceFromUserList"))
		{	*type = SOAP_TYPE_ns__DeleteDeviceFromUserList;
			return soap_in_ns__DeleteDeviceFromUserList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AssignDeviceToUser"))
		{	*type = SOAP_TYPE_ns__AssignDeviceToUser;
			return soap_in_ns__AssignDeviceToUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeleteUser"))
		{	*type = SOAP_TYPE_ns__DeleteUser;
			return soap_in_ns__DeleteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UpdateUser"))
		{	*type = SOAP_TYPE_ns__UpdateUser;
			return soap_in_ns__UpdateUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AddUser"))
		{	*type = SOAP_TYPE_ns__AddUser;
			return soap_in_ns__AddUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUsersList"))
		{	*type = SOAP_TYPE_ns__GetUsersList;
			return soap_in_ns__GetUsersList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllDeviceList"))
		{	*type = SOAP_TYPE_ns__GetAllDeviceList;
			return soap_in_ns__GetAllDeviceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserDeviceList"))
		{	*type = SOAP_TYPE_ns__GetUserDeviceList;
			return soap_in_ns__GetUserDeviceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Login"))
		{	*type = SOAP_TYPE_ns__Login;
			return soap_in_ns__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeleteDevices"))
		{	*type = SOAP_TYPE_ns__DeleteDevices;
			return soap_in_ns__DeleteDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetAllDeviceSetting"))
		{	*type = SOAP_TYPE_ns__SetAllDeviceSetting;
			return soap_in_ns__SetAllDeviceSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetAllDeviceSettingResponse"))
		{	*type = SOAP_TYPE_ns__SetAllDeviceSettingResponse;
			return soap_in_ns__SetAllDeviceSettingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetDeviceSetting"))
		{	*type = SOAP_TYPE_ns__SetDeviceSetting;
			return soap_in_ns__SetDeviceSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllDeviceStatus"))
		{	*type = SOAP_TYPE_ns__GetAllDeviceStatus;
			return soap_in_ns__GetAllDeviceStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDeviceStatus"))
		{	*type = SOAP_TYPE_ns__GetDeviceStatus;
			return soap_in_ns__GetDeviceStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tm"))
		{	*type = SOAP_TYPE_tm;
			return soap_in_tm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_out_xsd__long(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_out_xsd__double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns__SensorName:
		return soap_out_ns__SensorName(soap, tag, id, (const enum ns__SensorName *)ptr, "ns:SensorName");
	case SOAP_TYPE_ns__SensorType:
		return soap_out_ns__SensorType(soap, tag, id, (const enum ns__SensorType *)ptr, "ns:SensorType");
	case SOAP_TYPE_ns__SimcardType:
		return soap_out_ns__SimcardType(soap, tag, id, (const enum ns__SimcardType *)ptr, "ns:SimcardType");
	case SOAP_TYPE_ns__UserType:
		return soap_out_ns__UserType(soap, tag, id, (const enum ns__UserType *)ptr, "ns:UserType");
	case SOAP_TYPE_ns__SettingLevel:
		return soap_out_ns__SettingLevel(soap, tag, id, (const enum ns__SettingLevel *)ptr, "ns:SettingLevel");
	case SOAP_TYPE_ns__AllCityLocatoins:
		return ((ns__AllCityLocatoins *)ptr)->soap_out(soap, tag, id, "ns:AllCityLocatoins");
	case SOAP_TYPE_ns__CityLocation:
		return ((ns__CityLocation *)ptr)->soap_out(soap, tag, id, "ns:CityLocation");
	case SOAP_TYPE_ns__ServerOptions:
		return ((ns__ServerOptions *)ptr)->soap_out(soap, tag, id, "ns:ServerOptions");
	case SOAP_TYPE_ns__DataBaseInfo:
		return ((ns__DataBaseInfo *)ptr)->soap_out(soap, tag, id, "ns:DataBaseInfo");
	case SOAP_TYPE_ns__UserDevice:
		return ((ns__UserDevice *)ptr)->soap_out(soap, tag, id, "ns:UserDevice");
	case SOAP_TYPE_ns__UserDevices:
		return ((ns__UserDevices *)ptr)->soap_out(soap, tag, id, "ns:UserDevices");
	case SOAP_TYPE_ns__DeviceRules:
		return ((ns__DeviceRules *)ptr)->soap_out(soap, tag, id, "ns:DeviceRules");
	case SOAP_TYPE_ns__ErrorLog:
		return ((ns__ErrorLog *)ptr)->soap_out(soap, tag, id, "ns:ErrorLog");
	case SOAP_TYPE_ns__DeviceStatusInfo:
		return ((ns__DeviceStatusInfo *)ptr)->soap_out(soap, tag, id, "ns:DeviceStatusInfo");
	case SOAP_TYPE_ns__DeviceStatusLogList:
		return ((ns__DeviceStatusLogList *)ptr)->soap_out(soap, tag, id, "ns:DeviceStatusLogList");
	case SOAP_TYPE_ns__DeviceStatusLog:
		return ((ns__DeviceStatusLog *)ptr)->soap_out(soap, tag, id, "ns:DeviceStatusLog");
	case SOAP_TYPE_ns__UserLog:
		return ((ns__UserLog *)ptr)->soap_out(soap, tag, id, "ns:UserLog");
	case SOAP_TYPE_ns__ActivityLog:
		return ((ns__ActivityLog *)ptr)->soap_out(soap, tag, id, "ns:ActivityLog");
	case SOAP_TYPE_ns__Report:
		return ((ns__Report *)ptr)->soap_out(soap, tag, id, "ns:Report");
	case SOAP_TYPE_ns__Device:
		return ((ns__Device *)ptr)->soap_out(soap, tag, id, "ns:Device");
	case SOAP_TYPE_ns__Sensor:
		return ((ns__Sensor *)ptr)->soap_out(soap, tag, id, "ns:Sensor");
	case SOAP_TYPE_ns__Relay:
		return ((ns__Relay *)ptr)->soap_out(soap, tag, id, "ns:Relay");
	case SOAP_TYPE_ns__Mobile:
		return ((ns__Mobile *)ptr)->soap_out(soap, tag, id, "ns:Mobile");
	case SOAP_TYPE_ns__Gprs:
		return ((ns__Gprs *)ptr)->soap_out(soap, tag, id, "ns:Gprs");
	case SOAP_TYPE_ns__Server:
		return ((ns__Server *)ptr)->soap_out(soap, tag, id, "ns:Server");
	case SOAP_TYPE_ns__IP:
		return ((ns__IP *)ptr)->soap_out(soap, tag, id, "ns:IP");
	case SOAP_TYPE_ns__UsersList:
		return ((ns__UsersList *)ptr)->soap_out(soap, tag, id, "ns:UsersList");
	case SOAP_TYPE_ns__User:
		return ((ns__User *)ptr)->soap_out(soap, tag, id, "ns:User");
	case SOAP_TYPE_ns__ErrorCode:
		return ((ns__ErrorCode *)ptr)->soap_out(soap, tag, id, "ns:ErrorCode");
	case SOAP_TYPE_xsd__string:
		return soap_out_xsd__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns__TestWorld:
		return soap_out_ns__TestWorld(soap, tag, id, (const struct ns__TestWorld *)ptr, "ns:TestWorld");
	case SOAP_TYPE_ns__TestWorldResponse:
		return soap_out_ns__TestWorldResponse(soap, tag, id, (const struct ns__TestWorldResponse *)ptr, "ns:TestWorldResponse");
	case SOAP_TYPE_ns__ChangeDeviceName:
		return soap_out_ns__ChangeDeviceName(soap, tag, id, (const struct ns__ChangeDeviceName *)ptr, "ns:ChangeDeviceName");
	case SOAP_TYPE_ns__ChangeLocationName:
		return soap_out_ns__ChangeLocationName(soap, tag, id, (const struct ns__ChangeLocationName *)ptr, "ns:ChangeLocationName");
	case SOAP_TYPE_ns__ChangeCityName:
		return soap_out_ns__ChangeCityName(soap, tag, id, (const struct ns__ChangeCityName *)ptr, "ns:ChangeCityName");
	case SOAP_TYPE_ns__GetCityAndLocations:
		return soap_out_ns__GetCityAndLocations(soap, tag, id, (const struct ns__GetCityAndLocations *)ptr, "ns:GetCityAndLocations");
	case SOAP_TYPE_ns__SetServerOptions:
		return soap_out_ns__SetServerOptions(soap, tag, id, (const struct ns__SetServerOptions *)ptr, "ns:SetServerOptions");
	case SOAP_TYPE_ns__GetServerOptions:
		return soap_out_ns__GetServerOptions(soap, tag, id, (const struct ns__GetServerOptions *)ptr, "ns:GetServerOptions");
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		return soap_out_ns__GetDeviceStatusLog(soap, tag, id, (const struct ns__GetDeviceStatusLog *)ptr, "ns:GetDeviceStatusLog");
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		return soap_out_ns__SaveDeviceStatusLog(soap, tag, id, (const struct ns__SaveDeviceStatusLog *)ptr, "ns:SaveDeviceStatusLog");
	case SOAP_TYPE_ns__GetUserLog:
		return soap_out_ns__GetUserLog(soap, tag, id, (const struct ns__GetUserLog *)ptr, "ns:GetUserLog");
	case SOAP_TYPE_ns__GetUserLogResponse:
		return soap_out_ns__GetUserLogResponse(soap, tag, id, (const struct ns__GetUserLogResponse *)ptr, "ns:GetUserLogResponse");
	case SOAP_TYPE_ns__SaveUserLog:
		return soap_out_ns__SaveUserLog(soap, tag, id, (const struct ns__SaveUserLog *)ptr, "ns:SaveUserLog");
	case SOAP_TYPE_ns__GetActivityLog:
		return soap_out_ns__GetActivityLog(soap, tag, id, (const struct ns__GetActivityLog *)ptr, "ns:GetActivityLog");
	case SOAP_TYPE_ns__GetActivityLogResponse:
		return soap_out_ns__GetActivityLogResponse(soap, tag, id, (const struct ns__GetActivityLogResponse *)ptr, "ns:GetActivityLogResponse");
	case SOAP_TYPE_ns__SaveActivityLog:
		return soap_out_ns__SaveActivityLog(soap, tag, id, (const struct ns__SaveActivityLog *)ptr, "ns:SaveActivityLog");
	case SOAP_TYPE_ns__GetUserDevices:
		return soap_out_ns__GetUserDevices(soap, tag, id, (const struct ns__GetUserDevices *)ptr, "ns:GetUserDevices");
	case SOAP_TYPE_ns__DeleteDeviceFromUserList:
		return soap_out_ns__DeleteDeviceFromUserList(soap, tag, id, (const struct ns__DeleteDeviceFromUserList *)ptr, "ns:DeleteDeviceFromUserList");
	case SOAP_TYPE_ns__AssignDeviceToUser:
		return soap_out_ns__AssignDeviceToUser(soap, tag, id, (const struct ns__AssignDeviceToUser *)ptr, "ns:AssignDeviceToUser");
	case SOAP_TYPE_ns__DeleteUser:
		return soap_out_ns__DeleteUser(soap, tag, id, (const struct ns__DeleteUser *)ptr, "ns:DeleteUser");
	case SOAP_TYPE_ns__UpdateUser:
		return soap_out_ns__UpdateUser(soap, tag, id, (const struct ns__UpdateUser *)ptr, "ns:UpdateUser");
	case SOAP_TYPE_ns__AddUser:
		return soap_out_ns__AddUser(soap, tag, id, (const struct ns__AddUser *)ptr, "ns:AddUser");
	case SOAP_TYPE_ns__GetUsersList:
		return soap_out_ns__GetUsersList(soap, tag, id, (const struct ns__GetUsersList *)ptr, "ns:GetUsersList");
	case SOAP_TYPE_ns__GetAllDeviceList:
		return soap_out_ns__GetAllDeviceList(soap, tag, id, (const struct ns__GetAllDeviceList *)ptr, "ns:GetAllDeviceList");
	case SOAP_TYPE_ns__GetUserDeviceList:
		return soap_out_ns__GetUserDeviceList(soap, tag, id, (const struct ns__GetUserDeviceList *)ptr, "ns:GetUserDeviceList");
	case SOAP_TYPE_ns__Login:
		return soap_out_ns__Login(soap, tag, id, (const struct ns__Login *)ptr, "ns:Login");
	case SOAP_TYPE_ns__DeleteDevices:
		return soap_out_ns__DeleteDevices(soap, tag, id, (const struct ns__DeleteDevices *)ptr, "ns:DeleteDevices");
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		return soap_out_ns__SetAllDeviceSetting(soap, tag, id, (const struct ns__SetAllDeviceSetting *)ptr, "ns:SetAllDeviceSetting");
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		return soap_out_ns__SetAllDeviceSettingResponse(soap, tag, id, (const struct ns__SetAllDeviceSettingResponse *)ptr, "ns:SetAllDeviceSettingResponse");
	case SOAP_TYPE_ns__SetDeviceSetting:
		return soap_out_ns__SetDeviceSetting(soap, tag, id, (const struct ns__SetDeviceSetting *)ptr, "ns:SetDeviceSetting");
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		return soap_out_ns__GetAllDeviceStatus(soap, tag, id, (const struct ns__GetAllDeviceStatus *)ptr, "ns:GetAllDeviceStatus");
	case SOAP_TYPE_ns__GetDeviceStatus:
		return soap_out_ns__GetDeviceStatus(soap, tag, id, (const struct ns__GetDeviceStatus *)ptr, "ns:GetDeviceStatus");
	case SOAP_TYPE_xsd__dateTime:
		return soap_out_xsd__dateTime(soap, tag, id, (const struct tm *)ptr, "xsd:dateTime");
	case SOAP_TYPE_tm:
		return soap_out_tm(soap, tag, id, (const struct tm *)ptr, "tm");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns__AllCityLocatoins:
		((ns__AllCityLocatoins *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__CityLocation:
		((ns__CityLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ServerOptions:
		((ns__ServerOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DataBaseInfo:
		((ns__DataBaseInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__UserDevice:
		((ns__UserDevice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__UserDevices:
		((ns__UserDevices *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceRules:
		((ns__DeviceRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ErrorLog:
		((ns__ErrorLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceStatusInfo:
		((ns__DeviceStatusInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceStatusLogList:
		((ns__DeviceStatusLogList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceStatusLog:
		((ns__DeviceStatusLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__UserLog:
		((ns__UserLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ActivityLog:
		((ns__ActivityLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Report:
		((ns__Report *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Device:
		((ns__Device *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Sensor:
		((ns__Sensor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Relay:
		((ns__Relay *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Mobile:
		((ns__Mobile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Gprs:
		((ns__Gprs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Server:
		((ns__Server *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__IP:
		((ns__IP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__UsersList:
		((ns__UsersList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__User:
		((ns__User *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ErrorCode:
		((ns__ErrorCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_xsd__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns__TestWorld:
		soap_serialize_ns__TestWorld(soap, (const struct ns__TestWorld *)ptr);
		break;
	case SOAP_TYPE_ns__TestWorldResponse:
		soap_serialize_ns__TestWorldResponse(soap, (const struct ns__TestWorldResponse *)ptr);
		break;
	case SOAP_TYPE_ns__ChangeDeviceName:
		soap_serialize_ns__ChangeDeviceName(soap, (const struct ns__ChangeDeviceName *)ptr);
		break;
	case SOAP_TYPE_ns__ChangeLocationName:
		soap_serialize_ns__ChangeLocationName(soap, (const struct ns__ChangeLocationName *)ptr);
		break;
	case SOAP_TYPE_ns__ChangeCityName:
		soap_serialize_ns__ChangeCityName(soap, (const struct ns__ChangeCityName *)ptr);
		break;
	case SOAP_TYPE_ns__GetCityAndLocations:
		soap_serialize_ns__GetCityAndLocations(soap, (const struct ns__GetCityAndLocations *)ptr);
		break;
	case SOAP_TYPE_ns__SetServerOptions:
		soap_serialize_ns__SetServerOptions(soap, (const struct ns__SetServerOptions *)ptr);
		break;
	case SOAP_TYPE_ns__GetServerOptions:
		soap_serialize_ns__GetServerOptions(soap, (const struct ns__GetServerOptions *)ptr);
		break;
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		soap_serialize_ns__GetDeviceStatusLog(soap, (const struct ns__GetDeviceStatusLog *)ptr);
		break;
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		soap_serialize_ns__SaveDeviceStatusLog(soap, (const struct ns__SaveDeviceStatusLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserLog:
		soap_serialize_ns__GetUserLog(soap, (const struct ns__GetUserLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserLogResponse:
		soap_serialize_ns__GetUserLogResponse(soap, (const struct ns__GetUserLogResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SaveUserLog:
		soap_serialize_ns__SaveUserLog(soap, (const struct ns__SaveUserLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetActivityLog:
		soap_serialize_ns__GetActivityLog(soap, (const struct ns__GetActivityLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetActivityLogResponse:
		soap_serialize_ns__GetActivityLogResponse(soap, (const struct ns__GetActivityLogResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SaveActivityLog:
		soap_serialize_ns__SaveActivityLog(soap, (const struct ns__SaveActivityLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserDevices:
		soap_serialize_ns__GetUserDevices(soap, (const struct ns__GetUserDevices *)ptr);
		break;
	case SOAP_TYPE_ns__DeleteDeviceFromUserList:
		soap_serialize_ns__DeleteDeviceFromUserList(soap, (const struct ns__DeleteDeviceFromUserList *)ptr);
		break;
	case SOAP_TYPE_ns__AssignDeviceToUser:
		soap_serialize_ns__AssignDeviceToUser(soap, (const struct ns__AssignDeviceToUser *)ptr);
		break;
	case SOAP_TYPE_ns__DeleteUser:
		soap_serialize_ns__DeleteUser(soap, (const struct ns__DeleteUser *)ptr);
		break;
	case SOAP_TYPE_ns__UpdateUser:
		soap_serialize_ns__UpdateUser(soap, (const struct ns__UpdateUser *)ptr);
		break;
	case SOAP_TYPE_ns__AddUser:
		soap_serialize_ns__AddUser(soap, (const struct ns__AddUser *)ptr);
		break;
	case SOAP_TYPE_ns__GetUsersList:
		soap_serialize_ns__GetUsersList(soap, (const struct ns__GetUsersList *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllDeviceList:
		soap_serialize_ns__GetAllDeviceList(soap, (const struct ns__GetAllDeviceList *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserDeviceList:
		soap_serialize_ns__GetUserDeviceList(soap, (const struct ns__GetUserDeviceList *)ptr);
		break;
	case SOAP_TYPE_ns__Login:
		soap_serialize_ns__Login(soap, (const struct ns__Login *)ptr);
		break;
	case SOAP_TYPE_ns__DeleteDevices:
		soap_serialize_ns__DeleteDevices(soap, (const struct ns__DeleteDevices *)ptr);
		break;
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		soap_serialize_ns__SetAllDeviceSetting(soap, (const struct ns__SetAllDeviceSetting *)ptr);
		break;
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		soap_serialize_ns__SetAllDeviceSettingResponse(soap, (const struct ns__SetAllDeviceSettingResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SetDeviceSetting:
		soap_serialize_ns__SetDeviceSetting(soap, (const struct ns__SetDeviceSetting *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		soap_serialize_ns__GetAllDeviceStatus(soap, (const struct ns__GetAllDeviceStatus *)ptr);
		break;
	case SOAP_TYPE_ns__GetDeviceStatus:
		soap_serialize_ns__GetDeviceStatus(soap, (const struct ns__GetDeviceStatus *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		soap_serialize_xsd__dateTime(soap, (const struct tm *)ptr);
		break;
	case SOAP_TYPE_tm:
		soap_serialize_tm(soap, (const struct tm *)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 Server_Soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_tm:
		return (void*)soap_instantiate_tm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ErrorCode:
		return (void*)soap_instantiate_ns__ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__User:
		return (void*)soap_instantiate_ns__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UsersList:
		return (void*)soap_instantiate_ns__UsersList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__IP:
		return (void*)soap_instantiate_ns__IP(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Server:
		return (void*)soap_instantiate_ns__Server(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Gprs:
		return (void*)soap_instantiate_ns__Gprs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Mobile:
		return (void*)soap_instantiate_ns__Mobile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Relay:
		return (void*)soap_instantiate_ns__Relay(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Sensor:
		return (void*)soap_instantiate_ns__Sensor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Device:
		return (void*)soap_instantiate_ns__Device(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Report:
		return (void*)soap_instantiate_ns__Report(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ActivityLog:
		return (void*)soap_instantiate_ns__ActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UserLog:
		return (void*)soap_instantiate_ns__UserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceStatusLog:
		return (void*)soap_instantiate_ns__DeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceStatusLogList:
		return (void*)soap_instantiate_ns__DeviceStatusLogList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceStatusInfo:
		return (void*)soap_instantiate_ns__DeviceStatusInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ErrorLog:
		return (void*)soap_instantiate_ns__ErrorLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceRules:
		return (void*)soap_instantiate_ns__DeviceRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UserDevices:
		return (void*)soap_instantiate_ns__UserDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UserDevice:
		return (void*)soap_instantiate_ns__UserDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DataBaseInfo:
		return (void*)soap_instantiate_ns__DataBaseInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ServerOptions:
		return (void*)soap_instantiate_ns__ServerOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__CityLocation:
		return (void*)soap_instantiate_ns__CityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AllCityLocatoins:
		return (void*)soap_instantiate_ns__AllCityLocatoins(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDeviceStatus:
		return (void*)soap_instantiate_ns__GetDeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		return (void*)soap_instantiate_ns__GetAllDeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetDeviceSetting:
		return (void*)soap_instantiate_ns__SetDeviceSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		return (void*)soap_instantiate_ns__SetAllDeviceSettingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		return (void*)soap_instantiate_ns__SetAllDeviceSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeleteDevices:
		return (void*)soap_instantiate_ns__DeleteDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Login:
		return (void*)soap_instantiate_ns__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserDeviceList:
		return (void*)soap_instantiate_ns__GetUserDeviceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllDeviceList:
		return (void*)soap_instantiate_ns__GetAllDeviceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUsersList:
		return (void*)soap_instantiate_ns__GetUsersList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AddUser:
		return (void*)soap_instantiate_ns__AddUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UpdateUser:
		return (void*)soap_instantiate_ns__UpdateUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeleteUser:
		return (void*)soap_instantiate_ns__DeleteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AssignDeviceToUser:
		return (void*)soap_instantiate_ns__AssignDeviceToUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeleteDeviceFromUserList:
		return (void*)soap_instantiate_ns__DeleteDeviceFromUserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserDevices:
		return (void*)soap_instantiate_ns__GetUserDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SaveActivityLog:
		return (void*)soap_instantiate_ns__SaveActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetActivityLogResponse:
		return (void*)soap_instantiate_ns__GetActivityLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetActivityLog:
		return (void*)soap_instantiate_ns__GetActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SaveUserLog:
		return (void*)soap_instantiate_ns__SaveUserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserLogResponse:
		return (void*)soap_instantiate_ns__GetUserLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserLog:
		return (void*)soap_instantiate_ns__GetUserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		return (void*)soap_instantiate_ns__SaveDeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		return (void*)soap_instantiate_ns__GetDeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetServerOptions:
		return (void*)soap_instantiate_ns__GetServerOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetServerOptions:
		return (void*)soap_instantiate_ns__SetServerOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetCityAndLocations:
		return (void*)soap_instantiate_ns__GetCityAndLocations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ChangeCityName:
		return (void*)soap_instantiate_ns__ChangeCityName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ChangeLocationName:
		return (void*)soap_instantiate_ns__ChangeLocationName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ChangeDeviceName:
		return (void*)soap_instantiate_ns__ChangeDeviceName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__TestWorldResponse:
		return (void*)soap_instantiate_ns__TestWorldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__TestWorld:
		return (void*)soap_instantiate_ns__TestWorld(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__UserLog:
		return (void*)soap_instantiate_std__vectorTemplateOfns__UserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__ActivityLog:
		return (void*)soap_instantiate_std__vectorTemplateOfns__ActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__ErrorCode:
		return (void*)soap_instantiate_std__vectorTemplateOfns__ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__CityLocation:
		return (void*)soap_instantiate_std__vectorTemplateOfns__CityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceRules:
		return (void*)soap_instantiate_std__vectorTemplateOfns__DeviceRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__Device:
		return (void*)soap_instantiate_std__vectorTemplateOfns__Device(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog:
		return (void*)soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__Sensor:
		return (void*)soap_instantiate_std__vectorTemplateOfns__Sensor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__long:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__User:
		return (void*)soap_instantiate_std__vectorTemplateOfns__User(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 Server_Soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_tm:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct tm*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct tm*>(p->ptr));
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ErrorCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ErrorCode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ErrorCode*>(p->ptr));
		break;
	case SOAP_TYPE_ns__User:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__User*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__User*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UsersList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__UsersList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__UsersList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__IP:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__IP*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__IP*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Server:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Server*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Server*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Gprs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Gprs*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Gprs*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Mobile:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Mobile*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Mobile*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Relay:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Relay*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Relay*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Sensor:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Sensor*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Sensor*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Device:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Device*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Device*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Report:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Report*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Report*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ActivityLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ActivityLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__UserLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__UserLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DeviceStatusLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DeviceStatusLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeviceStatusLogList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DeviceStatusLogList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DeviceStatusLogList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeviceStatusInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DeviceStatusInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DeviceStatusInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ErrorLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ErrorLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ErrorLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeviceRules:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DeviceRules*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DeviceRules*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UserDevices:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__UserDevices*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__UserDevices*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UserDevice:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__UserDevice*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__UserDevice*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DataBaseInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DataBaseInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DataBaseInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ServerOptions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ServerOptions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ServerOptions*>(p->ptr));
		break;
	case SOAP_TYPE_ns__CityLocation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__CityLocation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__CityLocation*>(p->ptr));
		break;
	case SOAP_TYPE_ns__AllCityLocatoins:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__AllCityLocatoins*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__AllCityLocatoins*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDeviceStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDeviceStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDeviceStatus*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetAllDeviceStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetAllDeviceStatus*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetDeviceSetting:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetDeviceSetting*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetDeviceSetting*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetAllDeviceSettingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetAllDeviceSettingResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetAllDeviceSetting*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetAllDeviceSetting*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeleteDevices:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__DeleteDevices*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__DeleteDevices*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__Login*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserDeviceList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserDeviceList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserDeviceList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetAllDeviceList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetAllDeviceList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetAllDeviceList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUsersList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUsersList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUsersList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__AddUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__AddUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__AddUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UpdateUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__UpdateUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__UpdateUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeleteUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__DeleteUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__DeleteUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__AssignDeviceToUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__AssignDeviceToUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__AssignDeviceToUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeleteDeviceFromUserList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__DeleteDeviceFromUserList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__DeleteDeviceFromUserList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserDevices:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserDevices*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserDevices*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SaveActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SaveActivityLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SaveActivityLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetActivityLogResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetActivityLogResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetActivityLogResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetActivityLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetActivityLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SaveUserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SaveUserLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SaveUserLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserLogResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserLogResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserLogResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SaveDeviceStatusLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SaveDeviceStatusLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDeviceStatusLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDeviceStatusLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetServerOptions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetServerOptions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetServerOptions*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetServerOptions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetServerOptions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetServerOptions*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetCityAndLocations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetCityAndLocations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetCityAndLocations*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ChangeCityName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__ChangeCityName*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__ChangeCityName*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ChangeLocationName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__ChangeLocationName*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__ChangeLocationName*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ChangeDeviceName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__ChangeDeviceName*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__ChangeDeviceName*>(p->ptr));
		break;
	case SOAP_TYPE_ns__TestWorldResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__TestWorldResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__TestWorldResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__TestWorld:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__TestWorld*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__TestWorld*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct tm*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct tm*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__UserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__UserLog> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__UserLog> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__ActivityLog> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__ActivityLog> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ErrorCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__ErrorCode> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__ErrorCode> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__CityLocation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__CityLocation> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__CityLocation> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceRules:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__DeviceRules> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__DeviceRules> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Device:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__Device> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__Device> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__DeviceStatusLog> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__DeviceStatusLog> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Sensor:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__Sensor> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__Sensor> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__long:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<LONG64> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<LONG64> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__User:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__User> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__User> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 Server_Soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 Server_Soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfns__UserLog:
		if (t == SOAP_TYPE_ns__UserLog)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__UserLog>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__UserLog> *)p)[index] = *(ns__UserLog *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ActivityLog:
		if (t == SOAP_TYPE_ns__ActivityLog)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__ActivityLog>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__ActivityLog> *)p)[index] = *(ns__ActivityLog *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ErrorCode:
		if (t == SOAP_TYPE_ns__ErrorCode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__ErrorCode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__ErrorCode> *)p)[index] = *(ns__ErrorCode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__CityLocation:
		if (t == SOAP_TYPE_ns__CityLocation)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__CityLocation>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__CityLocation> *)p)[index] = *(ns__CityLocation *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		if (t == SOAP_TYPE_xsd__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceRules:
		if (t == SOAP_TYPE_ns__DeviceRules)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__DeviceRules>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__DeviceRules> *)p)[index] = *(ns__DeviceRules *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Device:
		if (t == SOAP_TYPE_ns__Device)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__Device>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__Device> *)p)[index] = *(ns__Device *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog:
		if (t == SOAP_TYPE_ns__DeviceStatusLog)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__DeviceStatusLog>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__DeviceStatusLog> *)p)[index] = *(ns__DeviceStatusLog *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Sensor:
		if (t == SOAP_TYPE_ns__Sensor)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__Sensor>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__Sensor> *)p)[index] = *(ns__Sensor *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__long:
		if (t == SOAP_TYPE_xsd__long)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<LONG64>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<LONG64> *)p)[index] = *(LONG64 *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__User:
		if (t == SOAP_TYPE_ns__User)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__User>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__User> *)p)[index] = *(ns__User *)q;
		}
		break;
	case SOAP_TYPE_tm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct tm type=%d location=%p object=%p\n", t, p, q));
		*(struct tm*)p = *(struct tm*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns__ErrorCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ErrorCode type=%d location=%p object=%p\n", t, p, q));
		*(ns__ErrorCode*)p = *(ns__ErrorCode*)q;
		break;
	case SOAP_TYPE_ns__User:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__User type=%d location=%p object=%p\n", t, p, q));
		*(ns__User*)p = *(ns__User*)q;
		break;
	case SOAP_TYPE_ns__UsersList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__UsersList type=%d location=%p object=%p\n", t, p, q));
		*(ns__UsersList*)p = *(ns__UsersList*)q;
		break;
	case SOAP_TYPE_ns__IP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__IP type=%d location=%p object=%p\n", t, p, q));
		*(ns__IP*)p = *(ns__IP*)q;
		break;
	case SOAP_TYPE_ns__Server:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Server type=%d location=%p object=%p\n", t, p, q));
		*(ns__Server*)p = *(ns__Server*)q;
		break;
	case SOAP_TYPE_ns__Gprs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Gprs type=%d location=%p object=%p\n", t, p, q));
		*(ns__Gprs*)p = *(ns__Gprs*)q;
		break;
	case SOAP_TYPE_ns__Mobile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Mobile type=%d location=%p object=%p\n", t, p, q));
		*(ns__Mobile*)p = *(ns__Mobile*)q;
		break;
	case SOAP_TYPE_ns__Relay:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Relay type=%d location=%p object=%p\n", t, p, q));
		*(ns__Relay*)p = *(ns__Relay*)q;
		break;
	case SOAP_TYPE_ns__Sensor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Sensor type=%d location=%p object=%p\n", t, p, q));
		*(ns__Sensor*)p = *(ns__Sensor*)q;
		break;
	case SOAP_TYPE_ns__Device:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Device type=%d location=%p object=%p\n", t, p, q));
		*(ns__Device*)p = *(ns__Device*)q;
		break;
	case SOAP_TYPE_ns__Report:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Report type=%d location=%p object=%p\n", t, p, q));
		*(ns__Report*)p = *(ns__Report*)q;
		break;
	case SOAP_TYPE_ns__ActivityLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ActivityLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__ActivityLog*)p = *(ns__ActivityLog*)q;
		break;
	case SOAP_TYPE_ns__UserLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__UserLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__UserLog*)p = *(ns__UserLog*)q;
		break;
	case SOAP_TYPE_ns__DeviceStatusLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DeviceStatusLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__DeviceStatusLog*)p = *(ns__DeviceStatusLog*)q;
		break;
	case SOAP_TYPE_ns__DeviceStatusLogList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DeviceStatusLogList type=%d location=%p object=%p\n", t, p, q));
		*(ns__DeviceStatusLogList*)p = *(ns__DeviceStatusLogList*)q;
		break;
	case SOAP_TYPE_ns__DeviceStatusInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DeviceStatusInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns__DeviceStatusInfo*)p = *(ns__DeviceStatusInfo*)q;
		break;
	case SOAP_TYPE_ns__ErrorLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ErrorLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__ErrorLog*)p = *(ns__ErrorLog*)q;
		break;
	case SOAP_TYPE_ns__DeviceRules:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DeviceRules type=%d location=%p object=%p\n", t, p, q));
		*(ns__DeviceRules*)p = *(ns__DeviceRules*)q;
		break;
	case SOAP_TYPE_ns__UserDevices:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__UserDevices type=%d location=%p object=%p\n", t, p, q));
		*(ns__UserDevices*)p = *(ns__UserDevices*)q;
		break;
	case SOAP_TYPE_ns__UserDevice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__UserDevice type=%d location=%p object=%p\n", t, p, q));
		*(ns__UserDevice*)p = *(ns__UserDevice*)q;
		break;
	case SOAP_TYPE_ns__DataBaseInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DataBaseInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns__DataBaseInfo*)p = *(ns__DataBaseInfo*)q;
		break;
	case SOAP_TYPE_ns__ServerOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ServerOptions type=%d location=%p object=%p\n", t, p, q));
		*(ns__ServerOptions*)p = *(ns__ServerOptions*)q;
		break;
	case SOAP_TYPE_ns__CityLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__CityLocation type=%d location=%p object=%p\n", t, p, q));
		*(ns__CityLocation*)p = *(ns__CityLocation*)q;
		break;
	case SOAP_TYPE_ns__AllCityLocatoins:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__AllCityLocatoins type=%d location=%p object=%p\n", t, p, q));
		*(ns__AllCityLocatoins*)p = *(ns__AllCityLocatoins*)q;
		break;
	case SOAP_TYPE_ns__GetDeviceStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDeviceStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDeviceStatus*)p = *(struct ns__GetDeviceStatus*)q;
		break;
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetAllDeviceStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetAllDeviceStatus*)p = *(struct ns__GetAllDeviceStatus*)q;
		break;
	case SOAP_TYPE_ns__SetDeviceSetting:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetDeviceSetting type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetDeviceSetting*)p = *(struct ns__SetDeviceSetting*)q;
		break;
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetAllDeviceSettingResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetAllDeviceSettingResponse*)p = *(struct ns__SetAllDeviceSettingResponse*)q;
		break;
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetAllDeviceSetting type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetAllDeviceSetting*)p = *(struct ns__SetAllDeviceSetting*)q;
		break;
	case SOAP_TYPE_ns__DeleteDevices:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__DeleteDevices type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__DeleteDevices*)p = *(struct ns__DeleteDevices*)q;
		break;
	case SOAP_TYPE_ns__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__Login type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__Login*)p = *(struct ns__Login*)q;
		break;
	case SOAP_TYPE_ns__GetUserDeviceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserDeviceList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserDeviceList*)p = *(struct ns__GetUserDeviceList*)q;
		break;
	case SOAP_TYPE_ns__GetAllDeviceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetAllDeviceList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetAllDeviceList*)p = *(struct ns__GetAllDeviceList*)q;
		break;
	case SOAP_TYPE_ns__GetUsersList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUsersList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUsersList*)p = *(struct ns__GetUsersList*)q;
		break;
	case SOAP_TYPE_ns__AddUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__AddUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__AddUser*)p = *(struct ns__AddUser*)q;
		break;
	case SOAP_TYPE_ns__UpdateUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__UpdateUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__UpdateUser*)p = *(struct ns__UpdateUser*)q;
		break;
	case SOAP_TYPE_ns__DeleteUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__DeleteUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__DeleteUser*)p = *(struct ns__DeleteUser*)q;
		break;
	case SOAP_TYPE_ns__AssignDeviceToUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__AssignDeviceToUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__AssignDeviceToUser*)p = *(struct ns__AssignDeviceToUser*)q;
		break;
	case SOAP_TYPE_ns__DeleteDeviceFromUserList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__DeleteDeviceFromUserList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__DeleteDeviceFromUserList*)p = *(struct ns__DeleteDeviceFromUserList*)q;
		break;
	case SOAP_TYPE_ns__GetUserDevices:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserDevices type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserDevices*)p = *(struct ns__GetUserDevices*)q;
		break;
	case SOAP_TYPE_ns__SaveActivityLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SaveActivityLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SaveActivityLog*)p = *(struct ns__SaveActivityLog*)q;
		break;
	case SOAP_TYPE_ns__GetActivityLogResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetActivityLogResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetActivityLogResponse*)p = *(struct ns__GetActivityLogResponse*)q;
		break;
	case SOAP_TYPE_ns__GetActivityLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetActivityLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetActivityLog*)p = *(struct ns__GetActivityLog*)q;
		break;
	case SOAP_TYPE_ns__SaveUserLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SaveUserLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SaveUserLog*)p = *(struct ns__SaveUserLog*)q;
		break;
	case SOAP_TYPE_ns__GetUserLogResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserLogResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserLogResponse*)p = *(struct ns__GetUserLogResponse*)q;
		break;
	case SOAP_TYPE_ns__GetUserLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserLog*)p = *(struct ns__GetUserLog*)q;
		break;
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SaveDeviceStatusLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SaveDeviceStatusLog*)p = *(struct ns__SaveDeviceStatusLog*)q;
		break;
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDeviceStatusLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDeviceStatusLog*)p = *(struct ns__GetDeviceStatusLog*)q;
		break;
	case SOAP_TYPE_ns__GetServerOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetServerOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetServerOptions*)p = *(struct ns__GetServerOptions*)q;
		break;
	case SOAP_TYPE_ns__SetServerOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetServerOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetServerOptions*)p = *(struct ns__SetServerOptions*)q;
		break;
	case SOAP_TYPE_ns__GetCityAndLocations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetCityAndLocations type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetCityAndLocations*)p = *(struct ns__GetCityAndLocations*)q;
		break;
	case SOAP_TYPE_ns__ChangeCityName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__ChangeCityName type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__ChangeCityName*)p = *(struct ns__ChangeCityName*)q;
		break;
	case SOAP_TYPE_ns__ChangeLocationName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__ChangeLocationName type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__ChangeLocationName*)p = *(struct ns__ChangeLocationName*)q;
		break;
	case SOAP_TYPE_ns__ChangeDeviceName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__ChangeDeviceName type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__ChangeDeviceName*)p = *(struct ns__ChangeDeviceName*)q;
		break;
	case SOAP_TYPE_ns__TestWorldResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__TestWorldResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__TestWorldResponse*)p = *(struct ns__TestWorldResponse*)q;
		break;
	case SOAP_TYPE_ns__TestWorld:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__TestWorld type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__TestWorld*)p = *(struct ns__TestWorld*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__dateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct tm type=%d location=%p object=%p\n", t, p, q));
		*(struct tm*)p = *(struct tm*)q;
		break;
	case SOAP_TYPE_xsd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_xsd__int(soap, tag?tag:"xsd:int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	a = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	if (soap_out_long(soap, tag?tag:"long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_xsd__long);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__long(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_xsd__long(soap, tag?tag:"xsd:long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag?tag:"long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag?tag:"float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_xsd__double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_xsd__double);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_xsd__double(soap, tag?tag:"xsd:double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag?tag:"double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dateTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dateTime
	*a = SOAP_DEFAULT_dateTime;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag?tag:"dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag?tag:"boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SensorName(struct soap *soap, enum ns__SensorName *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__SensorName
	*a = SOAP_DEFAULT_ns__SensorName;
#else
	*a = (enum ns__SensorName)0;
#endif
}

static const struct soap_code_map soap_codes_ns__SensorName[] =
{	{ (LONG64)TEMPERATURE, "TEMPERATURE" },
	{ (LONG64)HUMIDITY, "HUMIDITY" },
	{ (LONG64)H2S, "H2S" },
	{ (LONG64)PRESSER, "PRESSER" },
	{ (LONG64)GAS, "GAS" },
	{ (LONG64)ACVOLTAGE, "ACVOLTAGE" },
	{ (LONG64)ACVOLTAGE1, "ACVOLTAGE1" },
	{ (LONG64)ACVOLTAGE2, "ACVOLTAGE2" },
	{ (LONG64)ACVOLTAGE3, "ACVOLTAGE3" },
	{ (LONG64)ACAMPERE, "ACAMPERE" },
	{ (LONG64)ACAMPERE1, "ACAMPERE1" },
	{ (LONG64)ACAMPERE2, "ACAMPERE2" },
	{ (LONG64)ACAMPERE3, "ACAMPERE3" },
	{ (LONG64)DCVOLTAGE, "DCVOLTAGE" },
	{ (LONG64)DCAMPERE, "DCAMPERE" },
	{ (LONG64)SMOKE, "SMOKE" },
	{ (LONG64)MAGNET, "MAGNET" },
	{ (LONG64)WATER, "WATER" },
	{ (LONG64)MOTION, "MOTION" },
	{ (LONG64)DIGITAL, "DIGITAL" },
	{ (LONG64)UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SensorName2s(struct soap *soap, enum ns__SensorName n)
{	const char *s = soap_code_str(soap_codes_ns__SensorName, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorName(struct soap *soap, const char *tag, int id, const enum ns__SensorName *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SensorName), type) || soap_send(soap, soap_ns__SensorName2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SensorName(struct soap *soap, const char *s, enum ns__SensorName *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SensorName, s);
	if (map)
		*a = (enum ns__SensorName)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 20)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SensorName)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SensorName * SOAP_FMAC4 soap_in_ns__SensorName(struct soap *soap, const char *tag, enum ns__SensorName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SensorName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SensorName, sizeof(enum ns__SensorName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns__SensorName(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__SensorName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SensorName, SOAP_TYPE_ns__SensorName, sizeof(enum ns__SensorName), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SensorName(struct soap *soap, const enum ns__SensorName *a, const char *tag, const char *type)
{
	if (soap_out_ns__SensorName(soap, tag?tag:"ns:SensorName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SensorName * SOAP_FMAC4 soap_get_ns__SensorName(struct soap *soap, enum ns__SensorName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SensorName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SensorType(struct soap *soap, enum ns__SensorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__SensorType
	*a = SOAP_DEFAULT_ns__SensorType;
#else
	*a = (enum ns__SensorType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__SensorType[] =
{	{ (LONG64)Multi, "Multi" },
	{ (LONG64)Mono, "Mono" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SensorType2s(struct soap *soap, enum ns__SensorType n)
{	const char *s = soap_code_str(soap_codes_ns__SensorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorType(struct soap *soap, const char *tag, int id, const enum ns__SensorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SensorType), type) || soap_send(soap, soap_ns__SensorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SensorType(struct soap *soap, const char *s, enum ns__SensorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SensorType, s);
	if (map)
		*a = (enum ns__SensorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SensorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SensorType * SOAP_FMAC4 soap_in_ns__SensorType(struct soap *soap, const char *tag, enum ns__SensorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SensorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SensorType, sizeof(enum ns__SensorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns__SensorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__SensorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SensorType, SOAP_TYPE_ns__SensorType, sizeof(enum ns__SensorType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SensorType(struct soap *soap, const enum ns__SensorType *a, const char *tag, const char *type)
{
	if (soap_out_ns__SensorType(soap, tag?tag:"ns:SensorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SensorType * SOAP_FMAC4 soap_get_ns__SensorType(struct soap *soap, enum ns__SensorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SensorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SimcardType(struct soap *soap, enum ns__SimcardType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__SimcardType
	*a = SOAP_DEFAULT_ns__SimcardType;
#else
	*a = (enum ns__SimcardType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__SimcardType[] =
{	{ (LONG64)MCI, "MCI" },
	{ (LONG64)IranCell, "IranCell" },
	{ (LONG64)Taliya, "Taliya" },
	{ (LONG64)RighTel, "RighTel" },
	{ (LONG64)UnknownSim, "UnknownSim" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SimcardType2s(struct soap *soap, enum ns__SimcardType n)
{	const char *s = soap_code_str(soap_codes_ns__SimcardType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SimcardType(struct soap *soap, const char *tag, int id, const enum ns__SimcardType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SimcardType), type) || soap_send(soap, soap_ns__SimcardType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SimcardType(struct soap *soap, const char *s, enum ns__SimcardType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SimcardType, s);
	if (map)
		*a = (enum ns__SimcardType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SimcardType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SimcardType * SOAP_FMAC4 soap_in_ns__SimcardType(struct soap *soap, const char *tag, enum ns__SimcardType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SimcardType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SimcardType, sizeof(enum ns__SimcardType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns__SimcardType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__SimcardType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SimcardType, SOAP_TYPE_ns__SimcardType, sizeof(enum ns__SimcardType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SimcardType(struct soap *soap, const enum ns__SimcardType *a, const char *tag, const char *type)
{
	if (soap_out_ns__SimcardType(soap, tag?tag:"ns:SimcardType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SimcardType * SOAP_FMAC4 soap_get_ns__SimcardType(struct soap *soap, enum ns__SimcardType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SimcardType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__UserType(struct soap *soap, enum ns__UserType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__UserType
	*a = SOAP_DEFAULT_ns__UserType;
#else
	*a = (enum ns__UserType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__UserType[] =
{	{ (LONG64)Admin, "Admin" },
	{ (LONG64)Control, "Control" },
	{ (LONG64)Monitor, "Monitor" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__UserType2s(struct soap *soap, enum ns__UserType n)
{	const char *s = soap_code_str(soap_codes_ns__UserType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserType(struct soap *soap, const char *tag, int id, const enum ns__UserType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserType), type) || soap_send(soap, soap_ns__UserType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__UserType(struct soap *soap, const char *s, enum ns__UserType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__UserType, s);
	if (map)
		*a = (enum ns__UserType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__UserType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_in_ns__UserType(struct soap *soap, const char *tag, enum ns__UserType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__UserType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserType, sizeof(enum ns__UserType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns__UserType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__UserType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserType, SOAP_TYPE_ns__UserType, sizeof(enum ns__UserType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__UserType(struct soap *soap, const enum ns__UserType *a, const char *tag, const char *type)
{
	if (soap_out_ns__UserType(soap, tag?tag:"ns:UserType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_get_ns__UserType(struct soap *soap, enum ns__UserType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SettingLevel(struct soap *soap, enum ns__SettingLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__SettingLevel
	*a = SOAP_DEFAULT_ns__SettingLevel;
#else
	*a = (enum ns__SettingLevel)0;
#endif
}

static const struct soap_code_map soap_codes_ns__SettingLevel[] =
{	{ (LONG64)Normal, "Normal" },
	{ (LONG64)Disable, "Disable" },
	{ (LONG64)Warning, "Warning" },
	{ (LONG64)Minor, "Minor" },
	{ (LONG64)Major, "Major" },
	{ (LONG64)Critical, "Critical" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SettingLevel2s(struct soap *soap, enum ns__SettingLevel n)
{	const char *s = soap_code_str(soap_codes_ns__SettingLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SettingLevel(struct soap *soap, const char *tag, int id, const enum ns__SettingLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SettingLevel), type) || soap_send(soap, soap_ns__SettingLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SettingLevel(struct soap *soap, const char *s, enum ns__SettingLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SettingLevel, s);
	if (map)
		*a = (enum ns__SettingLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SettingLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SettingLevel * SOAP_FMAC4 soap_in_ns__SettingLevel(struct soap *soap, const char *tag, enum ns__SettingLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SettingLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SettingLevel, sizeof(enum ns__SettingLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns__SettingLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__SettingLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SettingLevel, SOAP_TYPE_ns__SettingLevel, sizeof(enum ns__SettingLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SettingLevel(struct soap *soap, const enum ns__SettingLevel *a, const char *tag, const char *type)
{
	if (soap_out_ns__SettingLevel(soap, tag?tag:"ns:SettingLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SettingLevel * SOAP_FMAC4 soap_get_ns__SettingLevel(struct soap *soap, enum ns__SettingLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SettingLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__AllCityLocatoins::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__CityLocation(soap, &this->ns__AllCityLocatoins::allCityLocatoins);
	this->ns__AllCityLocatoins::allCityLocatoinsError.ns__ErrorCode::soap_default(soap);
}

void ns__AllCityLocatoins::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__CityLocation(soap, &this->ns__AllCityLocatoins::allCityLocatoins);
	this->ns__AllCityLocatoins::allCityLocatoinsError.soap_serialize(soap);
#endif
}

int ns__AllCityLocatoins::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__AllCityLocatoins(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AllCityLocatoins(struct soap *soap, const char *tag, int id, const ns__AllCityLocatoins *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AllCityLocatoins), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__CityLocation(soap, "allCityLocatoins", -1, &a->ns__AllCityLocatoins::allCityLocatoins, ""))
		return soap->error;
	if ((a->ns__AllCityLocatoins::allCityLocatoinsError).soap_out(soap, "allCityLocatoinsError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__AllCityLocatoins::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__AllCityLocatoins(soap, tag, this, type);
}

SOAP_FMAC3 ns__AllCityLocatoins * SOAP_FMAC4 soap_in_ns__AllCityLocatoins(struct soap *soap, const char *tag, ns__AllCityLocatoins *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__AllCityLocatoins *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AllCityLocatoins, sizeof(ns__AllCityLocatoins), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_allCityLocatoinsError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__CityLocation(soap, "allCityLocatoins", &a->ns__AllCityLocatoins::allCityLocatoins, "ns:CityLocation"))
					continue;
			if (soap_flag_allCityLocatoinsError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__AllCityLocatoins::allCityLocatoinsError).soap_in(soap, "allCityLocatoinsError", "ns:ErrorCode"))
				{	soap_flag_allCityLocatoinsError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_allCityLocatoinsError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__AllCityLocatoins *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AllCityLocatoins, SOAP_TYPE_ns__AllCityLocatoins, sizeof(ns__AllCityLocatoins), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__AllCityLocatoins * SOAP_FMAC2 soap_instantiate_ns__AllCityLocatoins(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AllCityLocatoins(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__AllCityLocatoins *p;
	size_t k = sizeof(ns__AllCityLocatoins);
	if (n < 0)
	{	p = SOAP_NEW(ns__AllCityLocatoins);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__AllCityLocatoins, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__AllCityLocatoins location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__AllCityLocatoins, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__AllCityLocatoins::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:AllCityLocatoins", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__AllCityLocatoins::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__AllCityLocatoins(soap, this, tag, type);
}

SOAP_FMAC3 ns__AllCityLocatoins * SOAP_FMAC4 soap_get_ns__AllCityLocatoins(struct soap *soap, ns__AllCityLocatoins *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AllCityLocatoins(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__CityLocation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__CityLocation::cityLocationCityName = "";
	soap_default_std__vectorTemplateOfxsd__string(soap, &this->ns__CityLocation::cityLocationLocationsName);
	this->ns__CityLocation::cityLocationError.ns__ErrorCode::soap_default(soap);
}

void ns__CityLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__CityLocation::cityLocationCityName);
	soap_serialize_std__vectorTemplateOfxsd__string(soap, &this->ns__CityLocation::cityLocationLocationsName);
	this->ns__CityLocation::cityLocationError.soap_serialize(soap);
#endif
}

int ns__CityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__CityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__CityLocation(struct soap *soap, const char *tag, int id, const ns__CityLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__CityLocation), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "cityLocationCityName", -1, &a->ns__CityLocation::cityLocationCityName, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__string(soap, "cityLocationLocationsName", -1, &a->ns__CityLocation::cityLocationLocationsName, ""))
		return soap->error;
	if ((a->ns__CityLocation::cityLocationError).soap_out(soap, "cityLocationError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__CityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__CityLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns__CityLocation * SOAP_FMAC4 soap_in_ns__CityLocation(struct soap *soap, const char *tag, ns__CityLocation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__CityLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__CityLocation, sizeof(ns__CityLocation), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_cityLocationCityName1 = 1;
	size_t soap_flag_cityLocationError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cityLocationCityName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "cityLocationCityName", &a->ns__CityLocation::cityLocationCityName, "xsd:string"))
				{	soap_flag_cityLocationCityName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__string(soap, "cityLocationLocationsName", &a->ns__CityLocation::cityLocationLocationsName, "xsd:string"))
					continue;
			if (soap_flag_cityLocationError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__CityLocation::cityLocationError).soap_in(soap, "cityLocationError", "ns:ErrorCode"))
				{	soap_flag_cityLocationError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cityLocationError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__CityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__CityLocation, SOAP_TYPE_ns__CityLocation, sizeof(ns__CityLocation), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__CityLocation * SOAP_FMAC2 soap_instantiate_ns__CityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__CityLocation(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__CityLocation *p;
	size_t k = sizeof(ns__CityLocation);
	if (n < 0)
	{	p = SOAP_NEW(ns__CityLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__CityLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__CityLocation location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__CityLocation, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__CityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:CityLocation", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__CityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__CityLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns__CityLocation * SOAP_FMAC4 soap_get_ns__CityLocation(struct soap *soap, ns__CityLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__CityLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ServerOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ServerOptions::serverOptionsDataBaseInfo.ns__DataBaseInfo::soap_default(soap);
	this->ns__ServerOptions::serverOptionsTimeRepeat = 0;
	this->ns__ServerOptions::serverOptionsError.ns__ErrorCode::soap_default(soap);
}

void ns__ServerOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__ServerOptions::serverOptionsDataBaseInfo.soap_serialize(soap);
	this->ns__ServerOptions::serverOptionsError.soap_serialize(soap);
#endif
}

int ns__ServerOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ServerOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ServerOptions(struct soap *soap, const char *tag, int id, const ns__ServerOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ServerOptions), type))
		return soap->error;
	if ((a->ns__ServerOptions::serverOptionsDataBaseInfo).soap_out(soap, "serverOptionsDataBaseInfo", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "serverOptionsTimeRepeat", -1, &a->ns__ServerOptions::serverOptionsTimeRepeat, ""))
		return soap->error;
	if ((a->ns__ServerOptions::serverOptionsError).soap_out(soap, "serverOptionsError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ServerOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ServerOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns__ServerOptions * SOAP_FMAC4 soap_in_ns__ServerOptions(struct soap *soap, const char *tag, ns__ServerOptions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ServerOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ServerOptions, sizeof(ns__ServerOptions), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serverOptionsDataBaseInfo1 = 1;
	size_t soap_flag_serverOptionsTimeRepeat1 = 1;
	size_t soap_flag_serverOptionsError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serverOptionsDataBaseInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ServerOptions::serverOptionsDataBaseInfo).soap_in(soap, "serverOptionsDataBaseInfo", "ns:DataBaseInfo"))
				{	soap_flag_serverOptionsDataBaseInfo1--;
					continue;
				}
			if (soap_flag_serverOptionsTimeRepeat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "serverOptionsTimeRepeat", &a->ns__ServerOptions::serverOptionsTimeRepeat, "xsd:int"))
				{	soap_flag_serverOptionsTimeRepeat1--;
					continue;
				}
			if (soap_flag_serverOptionsError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ServerOptions::serverOptionsError).soap_in(soap, "serverOptionsError", "ns:ErrorCode"))
				{	soap_flag_serverOptionsError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serverOptionsDataBaseInfo1 > 0 || soap_flag_serverOptionsError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__ServerOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ServerOptions, SOAP_TYPE_ns__ServerOptions, sizeof(ns__ServerOptions), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ServerOptions * SOAP_FMAC2 soap_instantiate_ns__ServerOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ServerOptions(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ServerOptions *p;
	size_t k = sizeof(ns__ServerOptions);
	if (n < 0)
	{	p = SOAP_NEW(ns__ServerOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ServerOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ServerOptions location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ServerOptions, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ServerOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:ServerOptions", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ServerOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ServerOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns__ServerOptions * SOAP_FMAC4 soap_get_ns__ServerOptions(struct soap *soap, ns__ServerOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ServerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DataBaseInfo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__DataBaseInfo::dataBaseInfoServerName = "";
	this->ns__DataBaseInfo::dataBaseInfoPort = 0;
	this->ns__DataBaseInfo::dataBaseInfoUserName = "";
	this->ns__DataBaseInfo::dataBaseInfoPassWord = "";
	this->ns__DataBaseInfo::dataBaseInfoError.ns__ErrorCode::soap_default(soap);
}

void ns__DataBaseInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__DataBaseInfo::dataBaseInfoServerName);
	soap_serialize_xsd__string(soap, &this->ns__DataBaseInfo::dataBaseInfoUserName);
	soap_serialize_xsd__string(soap, &this->ns__DataBaseInfo::dataBaseInfoPassWord);
	this->ns__DataBaseInfo::dataBaseInfoError.soap_serialize(soap);
#endif
}

int ns__DataBaseInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DataBaseInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DataBaseInfo(struct soap *soap, const char *tag, int id, const ns__DataBaseInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DataBaseInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "dataBaseInfoServerName", -1, &a->ns__DataBaseInfo::dataBaseInfoServerName, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "dataBaseInfoPort", -1, &a->ns__DataBaseInfo::dataBaseInfoPort, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dataBaseInfoUserName", -1, &a->ns__DataBaseInfo::dataBaseInfoUserName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dataBaseInfoPassWord", -1, &a->ns__DataBaseInfo::dataBaseInfoPassWord, ""))
		return soap->error;
	if ((a->ns__DataBaseInfo::dataBaseInfoError).soap_out(soap, "dataBaseInfoError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DataBaseInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DataBaseInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns__DataBaseInfo * SOAP_FMAC4 soap_in_ns__DataBaseInfo(struct soap *soap, const char *tag, ns__DataBaseInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DataBaseInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DataBaseInfo, sizeof(ns__DataBaseInfo), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dataBaseInfoServerName1 = 1;
	size_t soap_flag_dataBaseInfoPort1 = 1;
	size_t soap_flag_dataBaseInfoUserName1 = 1;
	size_t soap_flag_dataBaseInfoPassWord1 = 1;
	size_t soap_flag_dataBaseInfoError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dataBaseInfoServerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "dataBaseInfoServerName", &a->ns__DataBaseInfo::dataBaseInfoServerName, "xsd:string"))
				{	soap_flag_dataBaseInfoServerName1--;
					continue;
				}
			if (soap_flag_dataBaseInfoPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "dataBaseInfoPort", &a->ns__DataBaseInfo::dataBaseInfoPort, "xsd:int"))
				{	soap_flag_dataBaseInfoPort1--;
					continue;
				}
			if (soap_flag_dataBaseInfoUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "dataBaseInfoUserName", &a->ns__DataBaseInfo::dataBaseInfoUserName, "xsd:string"))
				{	soap_flag_dataBaseInfoUserName1--;
					continue;
				}
			if (soap_flag_dataBaseInfoPassWord1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "dataBaseInfoPassWord", &a->ns__DataBaseInfo::dataBaseInfoPassWord, "xsd:string"))
				{	soap_flag_dataBaseInfoPassWord1--;
					continue;
				}
			if (soap_flag_dataBaseInfoError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__DataBaseInfo::dataBaseInfoError).soap_in(soap, "dataBaseInfoError", "ns:ErrorCode"))
				{	soap_flag_dataBaseInfoError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dataBaseInfoError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DataBaseInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DataBaseInfo, SOAP_TYPE_ns__DataBaseInfo, sizeof(ns__DataBaseInfo), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DataBaseInfo * SOAP_FMAC2 soap_instantiate_ns__DataBaseInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DataBaseInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DataBaseInfo *p;
	size_t k = sizeof(ns__DataBaseInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns__DataBaseInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DataBaseInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DataBaseInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DataBaseInfo, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DataBaseInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:DataBaseInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DataBaseInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DataBaseInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns__DataBaseInfo * SOAP_FMAC4 soap_get_ns__DataBaseInfo(struct soap *soap, ns__DataBaseInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DataBaseInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__UserDevice::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__UserDevice::userDeviceUser.ns__User::soap_default(soap);
	this->ns__UserDevice::userDeviceDevices.ns__UserDevices::soap_default(soap);
	this->ns__UserDevice::userDeviceError.ns__ErrorCode::soap_default(soap);
}

void ns__UserDevice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__UserDevice::userDeviceUser.soap_serialize(soap);
	this->ns__UserDevice::userDeviceDevices.soap_serialize(soap);
	this->ns__UserDevice::userDeviceError.soap_serialize(soap);
#endif
}

int ns__UserDevice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__UserDevice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserDevice(struct soap *soap, const char *tag, int id, const ns__UserDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserDevice), type))
		return soap->error;
	if ((a->ns__UserDevice::userDeviceUser).soap_out(soap, "userDeviceUser", -1, ""))
		return soap->error;
	if ((a->ns__UserDevice::userDeviceDevices).soap_out(soap, "userDeviceDevices", -1, ""))
		return soap->error;
	if ((a->ns__UserDevice::userDeviceError).soap_out(soap, "userDeviceError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__UserDevice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__UserDevice(soap, tag, this, type);
}

SOAP_FMAC3 ns__UserDevice * SOAP_FMAC4 soap_in_ns__UserDevice(struct soap *soap, const char *tag, ns__UserDevice *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__UserDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserDevice, sizeof(ns__UserDevice), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_userDeviceUser1 = 1;
	size_t soap_flag_userDeviceDevices1 = 1;
	size_t soap_flag_userDeviceError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userDeviceUser1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UserDevice::userDeviceUser).soap_in(soap, "userDeviceUser", "ns:User"))
				{	soap_flag_userDeviceUser1--;
					continue;
				}
			if (soap_flag_userDeviceDevices1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UserDevice::userDeviceDevices).soap_in(soap, "userDeviceDevices", "ns:UserDevices"))
				{	soap_flag_userDeviceDevices1--;
					continue;
				}
			if (soap_flag_userDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UserDevice::userDeviceError).soap_in(soap, "userDeviceError", "ns:ErrorCode"))
				{	soap_flag_userDeviceError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userDeviceUser1 > 0 || soap_flag_userDeviceDevices1 > 0 || soap_flag_userDeviceError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__UserDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserDevice, SOAP_TYPE_ns__UserDevice, sizeof(ns__UserDevice), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__UserDevice * SOAP_FMAC2 soap_instantiate_ns__UserDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UserDevice(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__UserDevice *p;
	size_t k = sizeof(ns__UserDevice);
	if (n < 0)
	{	p = SOAP_NEW(ns__UserDevice);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__UserDevice, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__UserDevice location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UserDevice, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__UserDevice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:UserDevice", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__UserDevice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__UserDevice(soap, this, tag, type);
}

SOAP_FMAC3 ns__UserDevice * SOAP_FMAC4 soap_get_ns__UserDevice(struct soap *soap, ns__UserDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__UserDevices::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__DeviceRules(soap, &this->ns__UserDevices::userDevices);
	this->ns__UserDevices::userDeviceError.ns__ErrorCode::soap_default(soap);
}

void ns__UserDevices::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__DeviceRules(soap, &this->ns__UserDevices::userDevices);
	this->ns__UserDevices::userDeviceError.soap_serialize(soap);
#endif
}

int ns__UserDevices::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__UserDevices(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserDevices(struct soap *soap, const char *tag, int id, const ns__UserDevices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserDevices), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__DeviceRules(soap, "userDevices", -1, &a->ns__UserDevices::userDevices, ""))
		return soap->error;
	if ((a->ns__UserDevices::userDeviceError).soap_out(soap, "userDeviceError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__UserDevices::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__UserDevices(soap, tag, this, type);
}

SOAP_FMAC3 ns__UserDevices * SOAP_FMAC4 soap_in_ns__UserDevices(struct soap *soap, const char *tag, ns__UserDevices *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__UserDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserDevices, sizeof(ns__UserDevices), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_userDeviceError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__DeviceRules(soap, "userDevices", &a->ns__UserDevices::userDevices, "ns:DeviceRules"))
					continue;
			if (soap_flag_userDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UserDevices::userDeviceError).soap_in(soap, "userDeviceError", "ns:ErrorCode"))
				{	soap_flag_userDeviceError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userDeviceError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__UserDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserDevices, SOAP_TYPE_ns__UserDevices, sizeof(ns__UserDevices), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__UserDevices * SOAP_FMAC2 soap_instantiate_ns__UserDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UserDevices(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__UserDevices *p;
	size_t k = sizeof(ns__UserDevices);
	if (n < 0)
	{	p = SOAP_NEW(ns__UserDevices);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__UserDevices, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__UserDevices location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UserDevices, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__UserDevices::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:UserDevices", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__UserDevices::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__UserDevices(soap, this, tag, type);
}

SOAP_FMAC3 ns__UserDevices * SOAP_FMAC4 soap_get_ns__UserDevices(struct soap *soap, ns__UserDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DeviceRules::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__DeviceRules::userDeviceDevice.ns__Device::soap_default(soap);
	this->ns__DeviceRules::userDeviceView = (bool)0;
	this->ns__DeviceRules::userDeviceUpdate = (bool)0;
	this->ns__DeviceRules::userDeviceDelete = (bool)0;
}

void ns__DeviceRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__DeviceRules::userDeviceDevice.soap_serialize(soap);
#endif
}

int ns__DeviceRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceRules(struct soap *soap, const char *tag, int id, const ns__DeviceRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceRules), type))
		return soap->error;
	if ((a->ns__DeviceRules::userDeviceDevice).soap_out(soap, "userDeviceDevice", -1, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "userDeviceView", -1, &a->ns__DeviceRules::userDeviceView, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "userDeviceUpdate", -1, &a->ns__DeviceRules::userDeviceUpdate, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "userDeviceDelete", -1, &a->ns__DeviceRules::userDeviceDelete, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceRules(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceRules * SOAP_FMAC4 soap_in_ns__DeviceRules(struct soap *soap, const char *tag, ns__DeviceRules *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceRules, sizeof(ns__DeviceRules), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_userDeviceDevice1 = 1;
	size_t soap_flag_userDeviceView1 = 1;
	size_t soap_flag_userDeviceUpdate1 = 1;
	size_t soap_flag_userDeviceDelete1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userDeviceDevice1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__DeviceRules::userDeviceDevice).soap_in(soap, "userDeviceDevice", "ns:Device"))
				{	soap_flag_userDeviceDevice1--;
					continue;
				}
			if (soap_flag_userDeviceView1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "userDeviceView", &a->ns__DeviceRules::userDeviceView, "xsd:boolean"))
				{	soap_flag_userDeviceView1--;
					continue;
				}
			if (soap_flag_userDeviceUpdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "userDeviceUpdate", &a->ns__DeviceRules::userDeviceUpdate, "xsd:boolean"))
				{	soap_flag_userDeviceUpdate1--;
					continue;
				}
			if (soap_flag_userDeviceDelete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "userDeviceDelete", &a->ns__DeviceRules::userDeviceDelete, "xsd:boolean"))
				{	soap_flag_userDeviceDelete1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userDeviceDevice1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DeviceRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceRules, SOAP_TYPE_ns__DeviceRules, sizeof(ns__DeviceRules), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DeviceRules * SOAP_FMAC2 soap_instantiate_ns__DeviceRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceRules(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DeviceRules *p;
	size_t k = sizeof(ns__DeviceRules);
	if (n < 0)
	{	p = SOAP_NEW(ns__DeviceRules);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DeviceRules, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DeviceRules location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeviceRules, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DeviceRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:DeviceRules", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DeviceRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceRules(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceRules * SOAP_FMAC4 soap_get_ns__DeviceRules(struct soap *soap, ns__DeviceRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ErrorLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__dateTime(soap, &this->ns__ErrorLog::errorLogDateTime);
	this->ns__ErrorLog::errorLogDevice.ns__Device::soap_default(soap);
	this->ns__ErrorLog::errorLogType = "";
	this->ns__ErrorLog::errorLogError.ns__ErrorCode::soap_default(soap);
}

void ns__ErrorLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__dateTime(soap, &this->ns__ErrorLog::errorLogDateTime);
	this->ns__ErrorLog::errorLogDevice.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &this->ns__ErrorLog::errorLogType);
	this->ns__ErrorLog::errorLogError.soap_serialize(soap);
#endif
}

int ns__ErrorLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ErrorLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ErrorLog(struct soap *soap, const char *tag, int id, const ns__ErrorLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ErrorLog), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "errorLogDateTime", -1, &a->ns__ErrorLog::errorLogDateTime, ""))
		return soap->error;
	if ((a->ns__ErrorLog::errorLogDevice).soap_out(soap, "errorLogDevice", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "errorLogType", -1, &a->ns__ErrorLog::errorLogType, ""))
		return soap->error;
	if ((a->ns__ErrorLog::errorLogError).soap_out(soap, "errorLogError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ErrorLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ErrorLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__ErrorLog * SOAP_FMAC4 soap_in_ns__ErrorLog(struct soap *soap, const char *tag, ns__ErrorLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ErrorLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ErrorLog, sizeof(ns__ErrorLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_errorLogDateTime1 = 1;
	size_t soap_flag_errorLogDevice1 = 1;
	size_t soap_flag_errorLogType1 = 1;
	size_t soap_flag_errorLogError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_errorLogDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "errorLogDateTime", &a->ns__ErrorLog::errorLogDateTime, "xsd:dateTime"))
				{	soap_flag_errorLogDateTime1--;
					continue;
				}
			if (soap_flag_errorLogDevice1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ErrorLog::errorLogDevice).soap_in(soap, "errorLogDevice", "ns:Device"))
				{	soap_flag_errorLogDevice1--;
					continue;
				}
			if (soap_flag_errorLogType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "errorLogType", &a->ns__ErrorLog::errorLogType, "xsd:string"))
				{	soap_flag_errorLogType1--;
					continue;
				}
			if (soap_flag_errorLogError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ErrorLog::errorLogError).soap_in(soap, "errorLogError", "ns:ErrorCode"))
				{	soap_flag_errorLogError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_errorLogDateTime1 > 0 || soap_flag_errorLogDevice1 > 0 || soap_flag_errorLogError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__ErrorLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ErrorLog, SOAP_TYPE_ns__ErrorLog, sizeof(ns__ErrorLog), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ErrorLog * SOAP_FMAC2 soap_instantiate_ns__ErrorLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ErrorLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ErrorLog *p;
	size_t k = sizeof(ns__ErrorLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__ErrorLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ErrorLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ErrorLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ErrorLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ErrorLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:ErrorLog", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ErrorLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ErrorLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__ErrorLog * SOAP_FMAC4 soap_get_ns__ErrorLog(struct soap *soap, ns__ErrorLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ErrorLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DeviceStatusInfo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__DeviceStatusInfo::deviceStatusInfoStartEndDateTime.ns__Report::soap_default(soap);
	soap_default_std__vectorTemplateOfns__Device(soap, &this->ns__DeviceStatusInfo::deviceStatusInfoDevice);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns__DeviceStatusInfo::deviceStatusInfoErrorType);
}

void ns__DeviceStatusInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__DeviceStatusInfo::deviceStatusInfoStartEndDateTime.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfns__Device(soap, &this->ns__DeviceStatusInfo::deviceStatusInfoDevice);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns__DeviceStatusInfo::deviceStatusInfoErrorType);
#endif
}

int ns__DeviceStatusInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceStatusInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusInfo(struct soap *soap, const char *tag, int id, const ns__DeviceStatusInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceStatusInfo), type))
		return soap->error;
	if ((a->ns__DeviceStatusInfo::deviceStatusInfoStartEndDateTime).soap_out(soap, "deviceStatusInfoStartEndDateTime", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Device(soap, "deviceStatusInfoDevice", -1, &a->ns__DeviceStatusInfo::deviceStatusInfoDevice, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "deviceStatusInfoErrorType", -1, &a->ns__DeviceStatusInfo::deviceStatusInfoErrorType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceStatusInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceStatusInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceStatusInfo * SOAP_FMAC4 soap_in_ns__DeviceStatusInfo(struct soap *soap, const char *tag, ns__DeviceStatusInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceStatusInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceStatusInfo, sizeof(ns__DeviceStatusInfo), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_deviceStatusInfoStartEndDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceStatusInfoStartEndDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__DeviceStatusInfo::deviceStatusInfoStartEndDateTime).soap_in(soap, "deviceStatusInfoStartEndDateTime", "ns:Report"))
				{	soap_flag_deviceStatusInfoStartEndDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__Device(soap, "deviceStatusInfoDevice", &a->ns__DeviceStatusInfo::deviceStatusInfoDevice, "ns:Device"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "deviceStatusInfoErrorType", &a->ns__DeviceStatusInfo::deviceStatusInfoErrorType, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceStatusInfoStartEndDateTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DeviceStatusInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceStatusInfo, SOAP_TYPE_ns__DeviceStatusInfo, sizeof(ns__DeviceStatusInfo), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DeviceStatusInfo * SOAP_FMAC2 soap_instantiate_ns__DeviceStatusInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceStatusInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DeviceStatusInfo *p;
	size_t k = sizeof(ns__DeviceStatusInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns__DeviceStatusInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DeviceStatusInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DeviceStatusInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeviceStatusInfo, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DeviceStatusInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:DeviceStatusInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DeviceStatusInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceStatusInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceStatusInfo * SOAP_FMAC4 soap_get_ns__DeviceStatusInfo(struct soap *soap, ns__DeviceStatusInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceStatusInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DeviceStatusLogList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__DeviceStatusLog(soap, &this->ns__DeviceStatusLogList::statusLogListStatus);
	this->ns__DeviceStatusLogList::statusLogListError.ns__ErrorCode::soap_default(soap);
}

void ns__DeviceStatusLogList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__DeviceStatusLog(soap, &this->ns__DeviceStatusLogList::statusLogListStatus);
	this->ns__DeviceStatusLogList::statusLogListError.soap_serialize(soap);
#endif
}

int ns__DeviceStatusLogList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceStatusLogList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusLogList(struct soap *soap, const char *tag, int id, const ns__DeviceStatusLogList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceStatusLogList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__DeviceStatusLog(soap, "statusLogListStatus", -1, &a->ns__DeviceStatusLogList::statusLogListStatus, ""))
		return soap->error;
	if ((a->ns__DeviceStatusLogList::statusLogListError).soap_out(soap, "statusLogListError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceStatusLogList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceStatusLogList(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceStatusLogList * SOAP_FMAC4 soap_in_ns__DeviceStatusLogList(struct soap *soap, const char *tag, ns__DeviceStatusLogList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceStatusLogList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceStatusLogList, sizeof(ns__DeviceStatusLogList), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusLogListError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__DeviceStatusLog(soap, "statusLogListStatus", &a->ns__DeviceStatusLogList::statusLogListStatus, "ns:DeviceStatusLog"))
					continue;
			if (soap_flag_statusLogListError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__DeviceStatusLogList::statusLogListError).soap_in(soap, "statusLogListError", "ns:ErrorCode"))
				{	soap_flag_statusLogListError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusLogListError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DeviceStatusLogList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceStatusLogList, SOAP_TYPE_ns__DeviceStatusLogList, sizeof(ns__DeviceStatusLogList), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DeviceStatusLogList * SOAP_FMAC2 soap_instantiate_ns__DeviceStatusLogList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceStatusLogList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DeviceStatusLogList *p;
	size_t k = sizeof(ns__DeviceStatusLogList);
	if (n < 0)
	{	p = SOAP_NEW(ns__DeviceStatusLogList);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DeviceStatusLogList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DeviceStatusLogList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeviceStatusLogList, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DeviceStatusLogList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:DeviceStatusLogList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DeviceStatusLogList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceStatusLogList(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceStatusLogList * SOAP_FMAC4 soap_get_ns__DeviceStatusLogList(struct soap *soap, ns__DeviceStatusLogList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceStatusLogList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DeviceStatusLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__DeviceStatusLog::statusLogStartEndDateTime.ns__Report::soap_default(soap);
	this->ns__DeviceStatusLog::statusLogDevice.ns__Device::soap_default(soap);
	this->ns__DeviceStatusLog::statusLogError.ns__ErrorCode::soap_default(soap);
}

void ns__DeviceStatusLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__DeviceStatusLog::statusLogStartEndDateTime.soap_serialize(soap);
	this->ns__DeviceStatusLog::statusLogDevice.soap_serialize(soap);
	this->ns__DeviceStatusLog::statusLogError.soap_serialize(soap);
#endif
}

int ns__DeviceStatusLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceStatusLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusLog(struct soap *soap, const char *tag, int id, const ns__DeviceStatusLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceStatusLog), type))
		return soap->error;
	if ((a->ns__DeviceStatusLog::statusLogStartEndDateTime).soap_out(soap, "statusLogStartEndDateTime", -1, ""))
		return soap->error;
	if ((a->ns__DeviceStatusLog::statusLogDevice).soap_out(soap, "statusLogDevice", -1, ""))
		return soap->error;
	if ((a->ns__DeviceStatusLog::statusLogError).soap_out(soap, "statusLogError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceStatusLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceStatusLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceStatusLog * SOAP_FMAC4 soap_in_ns__DeviceStatusLog(struct soap *soap, const char *tag, ns__DeviceStatusLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceStatusLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceStatusLog, sizeof(ns__DeviceStatusLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_statusLogStartEndDateTime1 = 1;
	size_t soap_flag_statusLogDevice1 = 1;
	size_t soap_flag_statusLogError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusLogStartEndDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__DeviceStatusLog::statusLogStartEndDateTime).soap_in(soap, "statusLogStartEndDateTime", "ns:Report"))
				{	soap_flag_statusLogStartEndDateTime1--;
					continue;
				}
			if (soap_flag_statusLogDevice1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__DeviceStatusLog::statusLogDevice).soap_in(soap, "statusLogDevice", "ns:Device"))
				{	soap_flag_statusLogDevice1--;
					continue;
				}
			if (soap_flag_statusLogError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__DeviceStatusLog::statusLogError).soap_in(soap, "statusLogError", "ns:ErrorCode"))
				{	soap_flag_statusLogError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusLogStartEndDateTime1 > 0 || soap_flag_statusLogDevice1 > 0 || soap_flag_statusLogError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DeviceStatusLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceStatusLog, SOAP_TYPE_ns__DeviceStatusLog, sizeof(ns__DeviceStatusLog), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DeviceStatusLog * SOAP_FMAC2 soap_instantiate_ns__DeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceStatusLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DeviceStatusLog *p;
	size_t k = sizeof(ns__DeviceStatusLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__DeviceStatusLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DeviceStatusLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DeviceStatusLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeviceStatusLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DeviceStatusLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:DeviceStatusLog", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DeviceStatusLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceStatusLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceStatusLog * SOAP_FMAC4 soap_get_ns__DeviceStatusLog(struct soap *soap, ns__DeviceStatusLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceStatusLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__UserLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__UserLog::userLogStartEndDateTime.ns__Report::soap_default(soap);
	this->ns__UserLog::userLogData = "";
	this->ns__UserLog::userLogUser.ns__User::soap_default(soap);
	this->ns__UserLog::userLogError.ns__ErrorCode::soap_default(soap);
}

void ns__UserLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__UserLog::userLogStartEndDateTime.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &this->ns__UserLog::userLogData);
	this->ns__UserLog::userLogUser.soap_serialize(soap);
	this->ns__UserLog::userLogError.soap_serialize(soap);
#endif
}

int ns__UserLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__UserLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserLog(struct soap *soap, const char *tag, int id, const ns__UserLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserLog), type))
		return soap->error;
	if ((a->ns__UserLog::userLogStartEndDateTime).soap_out(soap, "userLogStartEndDateTime", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userLogData", -1, &a->ns__UserLog::userLogData, ""))
		return soap->error;
	if ((a->ns__UserLog::userLogUser).soap_out(soap, "userLogUser", -1, ""))
		return soap->error;
	if ((a->ns__UserLog::userLogError).soap_out(soap, "userLogError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__UserLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__UserLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__UserLog * SOAP_FMAC4 soap_in_ns__UserLog(struct soap *soap, const char *tag, ns__UserLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__UserLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserLog, sizeof(ns__UserLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_userLogStartEndDateTime1 = 1;
	size_t soap_flag_userLogData1 = 1;
	size_t soap_flag_userLogUser1 = 1;
	size_t soap_flag_userLogError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userLogStartEndDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UserLog::userLogStartEndDateTime).soap_in(soap, "userLogStartEndDateTime", "ns:Report"))
				{	soap_flag_userLogStartEndDateTime1--;
					continue;
				}
			if (soap_flag_userLogData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userLogData", &a->ns__UserLog::userLogData, "xsd:string"))
				{	soap_flag_userLogData1--;
					continue;
				}
			if (soap_flag_userLogUser1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UserLog::userLogUser).soap_in(soap, "userLogUser", "ns:User"))
				{	soap_flag_userLogUser1--;
					continue;
				}
			if (soap_flag_userLogError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UserLog::userLogError).soap_in(soap, "userLogError", "ns:ErrorCode"))
				{	soap_flag_userLogError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userLogStartEndDateTime1 > 0 || soap_flag_userLogUser1 > 0 || soap_flag_userLogError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__UserLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserLog, SOAP_TYPE_ns__UserLog, sizeof(ns__UserLog), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__UserLog * SOAP_FMAC2 soap_instantiate_ns__UserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UserLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__UserLog *p;
	size_t k = sizeof(ns__UserLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__UserLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__UserLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__UserLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UserLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__UserLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:UserLog", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__UserLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__UserLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__UserLog * SOAP_FMAC4 soap_get_ns__UserLog(struct soap *soap, ns__UserLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ActivityLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ActivityLog::activityLogStartEndDateTime.ns__Report::soap_default(soap);
	this->ns__ActivityLog::activityLogData = "";
	this->ns__ActivityLog::activityLogDevice.ns__Device::soap_default(soap);
	this->ns__ActivityLog::activityLogUser.ns__User::soap_default(soap);
	this->ns__ActivityLog::activityError.ns__ErrorCode::soap_default(soap);
}

void ns__ActivityLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__ActivityLog::activityLogStartEndDateTime.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &this->ns__ActivityLog::activityLogData);
	this->ns__ActivityLog::activityLogDevice.soap_serialize(soap);
	this->ns__ActivityLog::activityLogUser.soap_serialize(soap);
	this->ns__ActivityLog::activityError.soap_serialize(soap);
#endif
}

int ns__ActivityLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ActivityLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ActivityLog(struct soap *soap, const char *tag, int id, const ns__ActivityLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ActivityLog), type))
		return soap->error;
	if ((a->ns__ActivityLog::activityLogStartEndDateTime).soap_out(soap, "activityLogStartEndDateTime", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "activityLogData", -1, &a->ns__ActivityLog::activityLogData, ""))
		return soap->error;
	if ((a->ns__ActivityLog::activityLogDevice).soap_out(soap, "activityLogDevice", -1, ""))
		return soap->error;
	if ((a->ns__ActivityLog::activityLogUser).soap_out(soap, "activityLogUser", -1, ""))
		return soap->error;
	if ((a->ns__ActivityLog::activityError).soap_out(soap, "activityError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ActivityLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ActivityLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__ActivityLog * SOAP_FMAC4 soap_in_ns__ActivityLog(struct soap *soap, const char *tag, ns__ActivityLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ActivityLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ActivityLog, sizeof(ns__ActivityLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_activityLogStartEndDateTime1 = 1;
	size_t soap_flag_activityLogData1 = 1;
	size_t soap_flag_activityLogDevice1 = 1;
	size_t soap_flag_activityLogUser1 = 1;
	size_t soap_flag_activityError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_activityLogStartEndDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ActivityLog::activityLogStartEndDateTime).soap_in(soap, "activityLogStartEndDateTime", "ns:Report"))
				{	soap_flag_activityLogStartEndDateTime1--;
					continue;
				}
			if (soap_flag_activityLogData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "activityLogData", &a->ns__ActivityLog::activityLogData, "xsd:string"))
				{	soap_flag_activityLogData1--;
					continue;
				}
			if (soap_flag_activityLogDevice1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ActivityLog::activityLogDevice).soap_in(soap, "activityLogDevice", "ns:Device"))
				{	soap_flag_activityLogDevice1--;
					continue;
				}
			if (soap_flag_activityLogUser1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ActivityLog::activityLogUser).soap_in(soap, "activityLogUser", "ns:User"))
				{	soap_flag_activityLogUser1--;
					continue;
				}
			if (soap_flag_activityError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__ActivityLog::activityError).soap_in(soap, "activityError", "ns:ErrorCode"))
				{	soap_flag_activityError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activityLogStartEndDateTime1 > 0 || soap_flag_activityLogDevice1 > 0 || soap_flag_activityLogUser1 > 0 || soap_flag_activityError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__ActivityLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ActivityLog, SOAP_TYPE_ns__ActivityLog, sizeof(ns__ActivityLog), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ActivityLog * SOAP_FMAC2 soap_instantiate_ns__ActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ActivityLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ActivityLog *p;
	size_t k = sizeof(ns__ActivityLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__ActivityLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ActivityLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ActivityLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ActivityLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ActivityLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:ActivityLog", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ActivityLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ActivityLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__ActivityLog * SOAP_FMAC4 soap_get_ns__ActivityLog(struct soap *soap, ns__ActivityLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ActivityLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Report::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__dateTime(soap, &this->ns__Report::reportStartDate);
	soap_default_xsd__dateTime(soap, &this->ns__Report::reportEndDate);
}

void ns__Report::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__dateTime(soap, &this->ns__Report::reportStartDate);
	soap_serialize_xsd__dateTime(soap, &this->ns__Report::reportEndDate);
#endif
}

int ns__Report::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Report(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Report(struct soap *soap, const char *tag, int id, const ns__Report *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Report), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "reportStartDate", -1, &a->ns__Report::reportStartDate, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "reportEndDate", -1, &a->ns__Report::reportEndDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Report::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Report(soap, tag, this, type);
}

SOAP_FMAC3 ns__Report * SOAP_FMAC4 soap_in_ns__Report(struct soap *soap, const char *tag, ns__Report *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Report *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Report, sizeof(ns__Report), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reportStartDate1 = 1;
	size_t soap_flag_reportEndDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reportStartDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "reportStartDate", &a->ns__Report::reportStartDate, "xsd:dateTime"))
				{	soap_flag_reportStartDate1--;
					continue;
				}
			if (soap_flag_reportEndDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "reportEndDate", &a->ns__Report::reportEndDate, "xsd:dateTime"))
				{	soap_flag_reportEndDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reportStartDate1 > 0 || soap_flag_reportEndDate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Report *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Report, SOAP_TYPE_ns__Report, sizeof(ns__Report), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Report * SOAP_FMAC2 soap_instantiate_ns__Report(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Report(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Report *p;
	size_t k = sizeof(ns__Report);
	if (n < 0)
	{	p = SOAP_NEW(ns__Report);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Report, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Report location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Report, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Report::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:Report", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Report::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Report(soap, this, tag, type);
}

SOAP_FMAC3 ns__Report * SOAP_FMAC4 soap_get_ns__Report(struct soap *soap, ns__Report *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Report(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Device::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Device::deviceSerialNumber = 0;
	this->ns__Device::deviceName = "";
	this->ns__Device::deviceFirmWareVersion = "";
	this->ns__Device::deviceNikeName = "";
	this->ns__Device::deviceLocation = "";
	this->ns__Device::deviceCity = "";
	this->ns__Device::deviceSocket = 0;
	soap_default_xsd__string(soap, &this->ns__Device::deviceDNSAddress);
	this->ns__Device::deviceIP.ns__IP::soap_default(soap);
	this->ns__Device::devicePort = 0;
	soap_default_xsd__dateTime(soap, &this->ns__Device::deviceDateTime);
	this->ns__Device::deviceMobileInfo.ns__Mobile::soap_default(soap);
	this->ns__Device::deviceServerInfo.ns__Server::soap_default(soap);
	this->ns__Device::deviceGprsInfo.ns__Gprs::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__long(soap, &this->ns__Device::deviceSMSContact);
	soap_default_std__vectorTemplateOfxsd__long(soap, &this->ns__Device::deviceSMSConfig);
	this->ns__Device::deviceFlags = "000000000000000000";
	this->ns__Device::deviceSMSCommand = (bool)0;
	this->ns__Device::deviceGSMCommand = (bool)0;
	this->ns__Device::deviceKeyBoardCommand = (bool)0;
	this->ns__Device::deviceBuzzerOnOff = (bool)0;
	this->ns__Device::deviceReset = (bool)0;
	soap_default_std__vectorTemplateOfns__Sensor(soap, &this->ns__Device::deviceSensors);
	this->ns__Device::deviceError.ns__ErrorCode::soap_default(soap);
}

void ns__Device::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__Device::deviceName);
	soap_serialize_xsd__string(soap, &this->ns__Device::deviceFirmWareVersion);
	soap_serialize_xsd__string(soap, &this->ns__Device::deviceNikeName);
	soap_serialize_xsd__string(soap, &this->ns__Device::deviceLocation);
	soap_serialize_xsd__string(soap, &this->ns__Device::deviceCity);
	soap_serialize_xsd__string(soap, &this->ns__Device::deviceDNSAddress);
	this->ns__Device::deviceIP.soap_serialize(soap);
	soap_serialize_xsd__dateTime(soap, &this->ns__Device::deviceDateTime);
	this->ns__Device::deviceMobileInfo.soap_serialize(soap);
	this->ns__Device::deviceServerInfo.soap_serialize(soap);
	this->ns__Device::deviceGprsInfo.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfxsd__long(soap, &this->ns__Device::deviceSMSContact);
	soap_serialize_std__vectorTemplateOfxsd__long(soap, &this->ns__Device::deviceSMSConfig);
	soap_serialize_xsd__string(soap, &this->ns__Device::deviceFlags);
	soap_serialize_std__vectorTemplateOfns__Sensor(soap, &this->ns__Device::deviceSensors);
	this->ns__Device::deviceError.soap_serialize(soap);
#endif
}

int ns__Device::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Device(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Device(struct soap *soap, const char *tag, int id, const ns__Device *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Device), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "deviceSerialNumber", -1, &a->ns__Device::deviceSerialNumber, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "deviceName", -1, &a->ns__Device::deviceName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "deviceFirmWareVersion", -1, &a->ns__Device::deviceFirmWareVersion, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "deviceNikeName", -1, &a->ns__Device::deviceNikeName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "deviceLocation", -1, &a->ns__Device::deviceLocation, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "deviceCity", -1, &a->ns__Device::deviceCity, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "deviceSocket", -1, &a->ns__Device::deviceSocket, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "deviceDNSAddress", -1, &a->ns__Device::deviceDNSAddress, ""))
		return soap->error;
	if ((a->ns__Device::deviceIP).soap_out(soap, "deviceIP", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "devicePort", -1, &a->ns__Device::devicePort, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "deviceDateTime", -1, &a->ns__Device::deviceDateTime, ""))
		return soap->error;
	if ((a->ns__Device::deviceMobileInfo).soap_out(soap, "deviceMobileInfo", -1, ""))
		return soap->error;
	if ((a->ns__Device::deviceServerInfo).soap_out(soap, "deviceServerInfo", -1, ""))
		return soap->error;
	if ((a->ns__Device::deviceGprsInfo).soap_out(soap, "deviceGprsInfo", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__long(soap, "deviceSMSContact", -1, &a->ns__Device::deviceSMSContact, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__long(soap, "deviceSMSConfig", -1, &a->ns__Device::deviceSMSConfig, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "deviceFlags", -1, &a->ns__Device::deviceFlags, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "deviceSMSCommand", -1, &a->ns__Device::deviceSMSCommand, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "deviceGSMCommand", -1, &a->ns__Device::deviceGSMCommand, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "deviceKeyBoardCommand", -1, &a->ns__Device::deviceKeyBoardCommand, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "deviceBuzzerOnOff", -1, &a->ns__Device::deviceBuzzerOnOff, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "deviceReset", -1, &a->ns__Device::deviceReset, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Sensor(soap, "deviceSensors", -1, &a->ns__Device::deviceSensors, ""))
		return soap->error;
	if ((a->ns__Device::deviceError).soap_out(soap, "deviceError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Device::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Device(soap, tag, this, type);
}

SOAP_FMAC3 ns__Device * SOAP_FMAC4 soap_in_ns__Device(struct soap *soap, const char *tag, ns__Device *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Device *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Device, sizeof(ns__Device), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_deviceSerialNumber1 = 1;
	size_t soap_flag_deviceName1 = 1;
	size_t soap_flag_deviceFirmWareVersion1 = 1;
	size_t soap_flag_deviceNikeName1 = 1;
	size_t soap_flag_deviceLocation1 = 1;
	size_t soap_flag_deviceCity1 = 1;
	size_t soap_flag_deviceSocket1 = 1;
	size_t soap_flag_deviceDNSAddress1 = 1;
	size_t soap_flag_deviceIP1 = 1;
	size_t soap_flag_devicePort1 = 1;
	size_t soap_flag_deviceDateTime1 = 1;
	size_t soap_flag_deviceMobileInfo1 = 1;
	size_t soap_flag_deviceServerInfo1 = 1;
	size_t soap_flag_deviceGprsInfo1 = 1;
	size_t soap_flag_deviceFlags1 = 1;
	size_t soap_flag_deviceSMSCommand1 = 1;
	size_t soap_flag_deviceGSMCommand1 = 1;
	size_t soap_flag_deviceKeyBoardCommand1 = 1;
	size_t soap_flag_deviceBuzzerOnOff1 = 1;
	size_t soap_flag_deviceReset1 = 1;
	size_t soap_flag_deviceError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceSerialNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "deviceSerialNumber", &a->ns__Device::deviceSerialNumber, "xsd:int"))
				{	soap_flag_deviceSerialNumber1--;
					continue;
				}
			if (soap_flag_deviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deviceName", &a->ns__Device::deviceName, "xsd:string"))
				{	soap_flag_deviceName1--;
					continue;
				}
			if (soap_flag_deviceFirmWareVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deviceFirmWareVersion", &a->ns__Device::deviceFirmWareVersion, "xsd:string"))
				{	soap_flag_deviceFirmWareVersion1--;
					continue;
				}
			if (soap_flag_deviceNikeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deviceNikeName", &a->ns__Device::deviceNikeName, "xsd:string"))
				{	soap_flag_deviceNikeName1--;
					continue;
				}
			if (soap_flag_deviceLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deviceLocation", &a->ns__Device::deviceLocation, "xsd:string"))
				{	soap_flag_deviceLocation1--;
					continue;
				}
			if (soap_flag_deviceCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deviceCity", &a->ns__Device::deviceCity, "xsd:string"))
				{	soap_flag_deviceCity1--;
					continue;
				}
			if (soap_flag_deviceSocket1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "deviceSocket", &a->ns__Device::deviceSocket, "xsd:int"))
				{	soap_flag_deviceSocket1--;
					continue;
				}
			if (soap_flag_deviceDNSAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deviceDNSAddress", &a->ns__Device::deviceDNSAddress, "xsd:string"))
				{	soap_flag_deviceDNSAddress1--;
					continue;
				}
			if (soap_flag_deviceIP1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Device::deviceIP).soap_in(soap, "deviceIP", "ns:IP"))
				{	soap_flag_deviceIP1--;
					continue;
				}
			if (soap_flag_devicePort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "devicePort", &a->ns__Device::devicePort, "xsd:int"))
				{	soap_flag_devicePort1--;
					continue;
				}
			if (soap_flag_deviceDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "deviceDateTime", &a->ns__Device::deviceDateTime, "xsd:dateTime"))
				{	soap_flag_deviceDateTime1--;
					continue;
				}
			if (soap_flag_deviceMobileInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Device::deviceMobileInfo).soap_in(soap, "deviceMobileInfo", "ns:Mobile"))
				{	soap_flag_deviceMobileInfo1--;
					continue;
				}
			if (soap_flag_deviceServerInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Device::deviceServerInfo).soap_in(soap, "deviceServerInfo", "ns:Server"))
				{	soap_flag_deviceServerInfo1--;
					continue;
				}
			if (soap_flag_deviceGprsInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Device::deviceGprsInfo).soap_in(soap, "deviceGprsInfo", "ns:Gprs"))
				{	soap_flag_deviceGprsInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__long(soap, "deviceSMSContact", &a->ns__Device::deviceSMSContact, "xsd:long"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__long(soap, "deviceSMSConfig", &a->ns__Device::deviceSMSConfig, "xsd:long"))
					continue;
			if (soap_flag_deviceFlags1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deviceFlags", &a->ns__Device::deviceFlags, "xsd:string"))
				{	soap_flag_deviceFlags1--;
					continue;
				}
			if (soap_flag_deviceSMSCommand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "deviceSMSCommand", &a->ns__Device::deviceSMSCommand, "xsd:boolean"))
				{	soap_flag_deviceSMSCommand1--;
					continue;
				}
			if (soap_flag_deviceGSMCommand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "deviceGSMCommand", &a->ns__Device::deviceGSMCommand, "xsd:boolean"))
				{	soap_flag_deviceGSMCommand1--;
					continue;
				}
			if (soap_flag_deviceKeyBoardCommand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "deviceKeyBoardCommand", &a->ns__Device::deviceKeyBoardCommand, "xsd:boolean"))
				{	soap_flag_deviceKeyBoardCommand1--;
					continue;
				}
			if (soap_flag_deviceBuzzerOnOff1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "deviceBuzzerOnOff", &a->ns__Device::deviceBuzzerOnOff, "xsd:boolean"))
				{	soap_flag_deviceBuzzerOnOff1--;
					continue;
				}
			if (soap_flag_deviceReset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "deviceReset", &a->ns__Device::deviceReset, "xsd:boolean"))
				{	soap_flag_deviceReset1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__Sensor(soap, "deviceSensors", &a->ns__Device::deviceSensors, "ns:Sensor"))
					continue;
			if (soap_flag_deviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Device::deviceError).soap_in(soap, "deviceError", "ns:ErrorCode"))
				{	soap_flag_deviceError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceDNSAddress1 > 0 || soap_flag_deviceIP1 > 0 || soap_flag_deviceDateTime1 > 0 || soap_flag_deviceMobileInfo1 > 0 || soap_flag_deviceServerInfo1 > 0 || soap_flag_deviceGprsInfo1 > 0 || soap_flag_deviceError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Device *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Device, SOAP_TYPE_ns__Device, sizeof(ns__Device), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Device * SOAP_FMAC2 soap_instantiate_ns__Device(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Device(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Device *p;
	size_t k = sizeof(ns__Device);
	if (n < 0)
	{	p = SOAP_NEW(ns__Device);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Device, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Device location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Device, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Device::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:Device", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Device::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Device(soap, this, tag, type);
}

SOAP_FMAC3 ns__Device * SOAP_FMAC4 soap_get_ns__Device(struct soap *soap, ns__Device *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Device(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Sensor::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Sensor::sensorName = (enum ns__SensorName)0;
	this->ns__Sensor::sensorNikeName = "";
	this->ns__Sensor::sensorValue = 0;
	this->ns__Sensor::sensorCalibration = 0;
	this->ns__Sensor::sensorMinimumValue = 0;
	this->ns__Sensor::sensorMaximumValue = 0;
	this->ns__Sensor::sensorMaximumThreshold = 0;
	this->ns__Sensor::sensorMinimumThreshold = 0;
	this->ns__Sensor::sensorSMSOnOff = (bool)0;
	this->ns__Sensor::sensorBuzzerOnOff = (bool)0;
	this->ns__Sensor::sensorRelay.ns__Relay::soap_default(soap);
	this->ns__Sensor::sensorLEDFlag = (bool)0;
	this->ns__Sensor::sensorType = (enum ns__SensorType)0;
	this->ns__Sensor::sensorError.ns__ErrorCode::soap_default(soap);
}

void ns__Sensor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__Sensor::sensorNikeName);
	this->ns__Sensor::sensorRelay.soap_serialize(soap);
	this->ns__Sensor::sensorError.soap_serialize(soap);
#endif
}

int ns__Sensor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Sensor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Sensor(struct soap *soap, const char *tag, int id, const ns__Sensor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Sensor), type))
		return soap->error;
	if (soap_out_ns__SensorName(soap, "sensorName", -1, &a->ns__Sensor::sensorName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sensorNikeName", -1, &a->ns__Sensor::sensorNikeName, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "sensorValue", -1, &a->ns__Sensor::sensorValue, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "sensorCalibration", -1, &a->ns__Sensor::sensorCalibration, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "sensorMinimumValue", -1, &a->ns__Sensor::sensorMinimumValue, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "sensorMaximumValue", -1, &a->ns__Sensor::sensorMaximumValue, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "sensorMaximumThreshold", -1, &a->ns__Sensor::sensorMaximumThreshold, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "sensorMinimumThreshold", -1, &a->ns__Sensor::sensorMinimumThreshold, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "sensorSMSOnOff", -1, &a->ns__Sensor::sensorSMSOnOff, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "sensorBuzzerOnOff", -1, &a->ns__Sensor::sensorBuzzerOnOff, ""))
		return soap->error;
	if ((a->ns__Sensor::sensorRelay).soap_out(soap, "sensorRelay", -1, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "sensorLEDFlag", -1, &a->ns__Sensor::sensorLEDFlag, ""))
		return soap->error;
	if (soap_out_ns__SensorType(soap, "sensorType", -1, &a->ns__Sensor::sensorType, ""))
		return soap->error;
	if ((a->ns__Sensor::sensorError).soap_out(soap, "sensorError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Sensor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Sensor(soap, tag, this, type);
}

SOAP_FMAC3 ns__Sensor * SOAP_FMAC4 soap_in_ns__Sensor(struct soap *soap, const char *tag, ns__Sensor *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Sensor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Sensor, sizeof(ns__Sensor), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sensorName1 = 1;
	size_t soap_flag_sensorNikeName1 = 1;
	size_t soap_flag_sensorValue1 = 1;
	size_t soap_flag_sensorCalibration1 = 1;
	size_t soap_flag_sensorMinimumValue1 = 1;
	size_t soap_flag_sensorMaximumValue1 = 1;
	size_t soap_flag_sensorMaximumThreshold1 = 1;
	size_t soap_flag_sensorMinimumThreshold1 = 1;
	size_t soap_flag_sensorSMSOnOff1 = 1;
	size_t soap_flag_sensorBuzzerOnOff1 = 1;
	size_t soap_flag_sensorRelay1 = 1;
	size_t soap_flag_sensorLEDFlag1 = 1;
	size_t soap_flag_sensorType1 = 1;
	size_t soap_flag_sensorError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sensorName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__SensorName(soap, "sensorName", &a->ns__Sensor::sensorName, "ns:SensorName"))
				{	soap_flag_sensorName1--;
					continue;
				}
			if (soap_flag_sensorNikeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "sensorNikeName", &a->ns__Sensor::sensorNikeName, "xsd:string"))
				{	soap_flag_sensorNikeName1--;
					continue;
				}
			if (soap_flag_sensorValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__double(soap, "sensorValue", &a->ns__Sensor::sensorValue, "xsd:double"))
				{	soap_flag_sensorValue1--;
					continue;
				}
			if (soap_flag_sensorCalibration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "sensorCalibration", &a->ns__Sensor::sensorCalibration, "xsd:int"))
				{	soap_flag_sensorCalibration1--;
					continue;
				}
			if (soap_flag_sensorMinimumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "sensorMinimumValue", &a->ns__Sensor::sensorMinimumValue, "xsd:int"))
				{	soap_flag_sensorMinimumValue1--;
					continue;
				}
			if (soap_flag_sensorMaximumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "sensorMaximumValue", &a->ns__Sensor::sensorMaximumValue, "xsd:int"))
				{	soap_flag_sensorMaximumValue1--;
					continue;
				}
			if (soap_flag_sensorMaximumThreshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "sensorMaximumThreshold", &a->ns__Sensor::sensorMaximumThreshold, "xsd:int"))
				{	soap_flag_sensorMaximumThreshold1--;
					continue;
				}
			if (soap_flag_sensorMinimumThreshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "sensorMinimumThreshold", &a->ns__Sensor::sensorMinimumThreshold, "xsd:int"))
				{	soap_flag_sensorMinimumThreshold1--;
					continue;
				}
			if (soap_flag_sensorSMSOnOff1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "sensorSMSOnOff", &a->ns__Sensor::sensorSMSOnOff, "xsd:boolean"))
				{	soap_flag_sensorSMSOnOff1--;
					continue;
				}
			if (soap_flag_sensorBuzzerOnOff1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "sensorBuzzerOnOff", &a->ns__Sensor::sensorBuzzerOnOff, "xsd:boolean"))
				{	soap_flag_sensorBuzzerOnOff1--;
					continue;
				}
			if (soap_flag_sensorRelay1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Sensor::sensorRelay).soap_in(soap, "sensorRelay", "ns:Relay"))
				{	soap_flag_sensorRelay1--;
					continue;
				}
			if (soap_flag_sensorLEDFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "sensorLEDFlag", &a->ns__Sensor::sensorLEDFlag, "xsd:boolean"))
				{	soap_flag_sensorLEDFlag1--;
					continue;
				}
			if (soap_flag_sensorType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__SensorType(soap, "sensorType", &a->ns__Sensor::sensorType, "ns:SensorType"))
				{	soap_flag_sensorType1--;
					continue;
				}
			if (soap_flag_sensorError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Sensor::sensorError).soap_in(soap, "sensorError", "ns:ErrorCode"))
				{	soap_flag_sensorError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sensorRelay1 > 0 || soap_flag_sensorError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Sensor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Sensor, SOAP_TYPE_ns__Sensor, sizeof(ns__Sensor), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Sensor * SOAP_FMAC2 soap_instantiate_ns__Sensor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Sensor(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Sensor *p;
	size_t k = sizeof(ns__Sensor);
	if (n < 0)
	{	p = SOAP_NEW(ns__Sensor);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Sensor, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Sensor location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Sensor, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Sensor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:Sensor", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Sensor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Sensor(soap, this, tag, type);
}

SOAP_FMAC3 ns__Sensor * SOAP_FMAC4 soap_get_ns__Sensor(struct soap *soap, ns__Sensor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Sensor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Relay::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Relay::relayIndex = 0;
	this->ns__Relay::relayOnOff = (bool)0;
}

void ns__Relay::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns__Relay::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Relay(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Relay(struct soap *soap, const char *tag, int id, const ns__Relay *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Relay), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "relayIndex", -1, &a->ns__Relay::relayIndex, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "relayOnOff", -1, &a->ns__Relay::relayOnOff, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Relay::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Relay(soap, tag, this, type);
}

SOAP_FMAC3 ns__Relay * SOAP_FMAC4 soap_in_ns__Relay(struct soap *soap, const char *tag, ns__Relay *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Relay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Relay, sizeof(ns__Relay), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_relayIndex1 = 1;
	size_t soap_flag_relayOnOff1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_relayIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "relayIndex", &a->ns__Relay::relayIndex, "xsd:int"))
				{	soap_flag_relayIndex1--;
					continue;
				}
			if (soap_flag_relayOnOff1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "relayOnOff", &a->ns__Relay::relayOnOff, "xsd:boolean"))
				{	soap_flag_relayOnOff1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Relay *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Relay, SOAP_TYPE_ns__Relay, sizeof(ns__Relay), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Relay * SOAP_FMAC2 soap_instantiate_ns__Relay(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Relay(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Relay *p;
	size_t k = sizeof(ns__Relay);
	if (n < 0)
	{	p = SOAP_NEW(ns__Relay);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Relay, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Relay location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Relay, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Relay::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:Relay", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Relay::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Relay(soap, this, tag, type);
}

SOAP_FMAC3 ns__Relay * SOAP_FMAC4 soap_get_ns__Relay(struct soap *soap, ns__Relay *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Relay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Mobile::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Mobile::mobileNumber = 0LL;
	this->ns__Mobile::mobileSimCardType = (enum ns__SimcardType)0;
	this->ns__Mobile::mobileChargeValue = 0;
	this->ns__Mobile::mobileSignalValue = 0;
}

void ns__Mobile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns__Mobile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Mobile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Mobile(struct soap *soap, const char *tag, int id, const ns__Mobile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Mobile), type))
		return soap->error;
	if (soap_out_xsd__long(soap, "mobileNumber", -1, &a->ns__Mobile::mobileNumber, ""))
		return soap->error;
	if (soap_out_ns__SimcardType(soap, "mobileSimCardType", -1, &a->ns__Mobile::mobileSimCardType, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "mobileChargeValue", -1, &a->ns__Mobile::mobileChargeValue, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "mobileSignalValue", -1, &a->ns__Mobile::mobileSignalValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Mobile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Mobile(soap, tag, this, type);
}

SOAP_FMAC3 ns__Mobile * SOAP_FMAC4 soap_in_ns__Mobile(struct soap *soap, const char *tag, ns__Mobile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Mobile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Mobile, sizeof(ns__Mobile), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_mobileNumber1 = 1;
	size_t soap_flag_mobileSimCardType1 = 1;
	size_t soap_flag_mobileChargeValue1 = 1;
	size_t soap_flag_mobileSignalValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mobileNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__long(soap, "mobileNumber", &a->ns__Mobile::mobileNumber, "xsd:long"))
				{	soap_flag_mobileNumber1--;
					continue;
				}
			if (soap_flag_mobileSimCardType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__SimcardType(soap, "mobileSimCardType", &a->ns__Mobile::mobileSimCardType, "ns:SimcardType"))
				{	soap_flag_mobileSimCardType1--;
					continue;
				}
			if (soap_flag_mobileChargeValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "mobileChargeValue", &a->ns__Mobile::mobileChargeValue, "xsd:int"))
				{	soap_flag_mobileChargeValue1--;
					continue;
				}
			if (soap_flag_mobileSignalValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "mobileSignalValue", &a->ns__Mobile::mobileSignalValue, "xsd:int"))
				{	soap_flag_mobileSignalValue1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Mobile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Mobile, SOAP_TYPE_ns__Mobile, sizeof(ns__Mobile), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Mobile * SOAP_FMAC2 soap_instantiate_ns__Mobile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Mobile(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Mobile *p;
	size_t k = sizeof(ns__Mobile);
	if (n < 0)
	{	p = SOAP_NEW(ns__Mobile);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Mobile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Mobile location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Mobile, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Mobile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:Mobile", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Mobile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Mobile(soap, this, tag, type);
}

SOAP_FMAC3 ns__Mobile * SOAP_FMAC4 soap_get_ns__Mobile(struct soap *soap, ns__Mobile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Mobile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Gprs::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->ns__Gprs::gprsDNSAddress);
	this->ns__Gprs::gprsIP.ns__IP::soap_default(soap);
	this->ns__Gprs::gprsPort = 0;
	this->ns__Gprs::gprsError.ns__ErrorCode::soap_default(soap);
}

void ns__Gprs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__Gprs::gprsDNSAddress);
	this->ns__Gprs::gprsIP.soap_serialize(soap);
	this->ns__Gprs::gprsError.soap_serialize(soap);
#endif
}

int ns__Gprs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Gprs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Gprs(struct soap *soap, const char *tag, int id, const ns__Gprs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Gprs), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "gprsDNSAddress", -1, &a->ns__Gprs::gprsDNSAddress, ""))
		return soap->error;
	if ((a->ns__Gprs::gprsIP).soap_out(soap, "gprsIP", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "gprsPort", -1, &a->ns__Gprs::gprsPort, ""))
		return soap->error;
	if ((a->ns__Gprs::gprsError).soap_out(soap, "gprsError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Gprs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Gprs(soap, tag, this, type);
}

SOAP_FMAC3 ns__Gprs * SOAP_FMAC4 soap_in_ns__Gprs(struct soap *soap, const char *tag, ns__Gprs *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Gprs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Gprs, sizeof(ns__Gprs), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_gprsDNSAddress1 = 1;
	size_t soap_flag_gprsIP1 = 1;
	size_t soap_flag_gprsPort1 = 1;
	size_t soap_flag_gprsError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gprsDNSAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "gprsDNSAddress", &a->ns__Gprs::gprsDNSAddress, "xsd:string"))
				{	soap_flag_gprsDNSAddress1--;
					continue;
				}
			if (soap_flag_gprsIP1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Gprs::gprsIP).soap_in(soap, "gprsIP", "ns:IP"))
				{	soap_flag_gprsIP1--;
					continue;
				}
			if (soap_flag_gprsPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "gprsPort", &a->ns__Gprs::gprsPort, "xsd:int"))
				{	soap_flag_gprsPort1--;
					continue;
				}
			if (soap_flag_gprsError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Gprs::gprsError).soap_in(soap, "gprsError", "ns:ErrorCode"))
				{	soap_flag_gprsError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gprsDNSAddress1 > 0 || soap_flag_gprsIP1 > 0 || soap_flag_gprsError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Gprs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Gprs, SOAP_TYPE_ns__Gprs, sizeof(ns__Gprs), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Gprs * SOAP_FMAC2 soap_instantiate_ns__Gprs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Gprs(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Gprs *p;
	size_t k = sizeof(ns__Gprs);
	if (n < 0)
	{	p = SOAP_NEW(ns__Gprs);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Gprs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Gprs location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Gprs, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Gprs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:Gprs", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Gprs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Gprs(soap, this, tag, type);
}

SOAP_FMAC3 ns__Gprs * SOAP_FMAC4 soap_get_ns__Gprs(struct soap *soap, ns__Gprs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Gprs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Server::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->ns__Server::serverDNSAddress);
	this->ns__Server::serverIP.ns__IP::soap_default(soap);
	this->ns__Server::serverPort = 0;
	this->ns__Server::serverError.ns__ErrorCode::soap_default(soap);
}

void ns__Server::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__Server::serverDNSAddress);
	this->ns__Server::serverIP.soap_serialize(soap);
	this->ns__Server::serverError.soap_serialize(soap);
#endif
}

int ns__Server::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Server(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Server(struct soap *soap, const char *tag, int id, const ns__Server *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Server), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "serverDNSAddress", -1, &a->ns__Server::serverDNSAddress, ""))
		return soap->error;
	if ((a->ns__Server::serverIP).soap_out(soap, "serverIP", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "serverPort", -1, &a->ns__Server::serverPort, ""))
		return soap->error;
	if ((a->ns__Server::serverError).soap_out(soap, "serverError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Server::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Server(soap, tag, this, type);
}

SOAP_FMAC3 ns__Server * SOAP_FMAC4 soap_in_ns__Server(struct soap *soap, const char *tag, ns__Server *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Server *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Server, sizeof(ns__Server), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serverDNSAddress1 = 1;
	size_t soap_flag_serverIP1 = 1;
	size_t soap_flag_serverPort1 = 1;
	size_t soap_flag_serverError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serverDNSAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "serverDNSAddress", &a->ns__Server::serverDNSAddress, "xsd:string"))
				{	soap_flag_serverDNSAddress1--;
					continue;
				}
			if (soap_flag_serverIP1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Server::serverIP).soap_in(soap, "serverIP", "ns:IP"))
				{	soap_flag_serverIP1--;
					continue;
				}
			if (soap_flag_serverPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "serverPort", &a->ns__Server::serverPort, "xsd:int"))
				{	soap_flag_serverPort1--;
					continue;
				}
			if (soap_flag_serverError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Server::serverError).soap_in(soap, "serverError", "ns:ErrorCode"))
				{	soap_flag_serverError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serverDNSAddress1 > 0 || soap_flag_serverIP1 > 0 || soap_flag_serverError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Server *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Server, SOAP_TYPE_ns__Server, sizeof(ns__Server), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Server * SOAP_FMAC2 soap_instantiate_ns__Server(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Server(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Server *p;
	size_t k = sizeof(ns__Server);
	if (n < 0)
	{	p = SOAP_NEW(ns__Server);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Server, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Server location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Server, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Server::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:Server", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Server::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Server(soap, this, tag, type);
}

SOAP_FMAC3 ns__Server * SOAP_FMAC4 soap_get_ns__Server(struct soap *soap, ns__Server *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Server(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__IP::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__IP::ipFirst = 0;
	this->ns__IP::ipSecond = 0;
	this->ns__IP::ipThird = 0;
	this->ns__IP::ipFourth = 0;
}

void ns__IP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns__IP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__IP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__IP(struct soap *soap, const char *tag, int id, const ns__IP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__IP), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "ipFirst", -1, &a->ns__IP::ipFirst, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "ipSecond", -1, &a->ns__IP::ipSecond, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "ipThird", -1, &a->ns__IP::ipThird, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "ipFourth", -1, &a->ns__IP::ipFourth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__IP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__IP(soap, tag, this, type);
}

SOAP_FMAC3 ns__IP * SOAP_FMAC4 soap_in_ns__IP(struct soap *soap, const char *tag, ns__IP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__IP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__IP, sizeof(ns__IP), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ipFirst1 = 1;
	size_t soap_flag_ipSecond1 = 1;
	size_t soap_flag_ipThird1 = 1;
	size_t soap_flag_ipFourth1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ipFirst1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "ipFirst", &a->ns__IP::ipFirst, "xsd:int"))
				{	soap_flag_ipFirst1--;
					continue;
				}
			if (soap_flag_ipSecond1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "ipSecond", &a->ns__IP::ipSecond, "xsd:int"))
				{	soap_flag_ipSecond1--;
					continue;
				}
			if (soap_flag_ipThird1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "ipThird", &a->ns__IP::ipThird, "xsd:int"))
				{	soap_flag_ipThird1--;
					continue;
				}
			if (soap_flag_ipFourth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "ipFourth", &a->ns__IP::ipFourth, "xsd:int"))
				{	soap_flag_ipFourth1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__IP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__IP, SOAP_TYPE_ns__IP, sizeof(ns__IP), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__IP * SOAP_FMAC2 soap_instantiate_ns__IP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__IP(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__IP *p;
	size_t k = sizeof(ns__IP);
	if (n < 0)
	{	p = SOAP_NEW(ns__IP);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__IP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__IP location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__IP, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__IP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:IP", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__IP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__IP(soap, this, tag, type);
}

SOAP_FMAC3 ns__IP * SOAP_FMAC4 soap_get_ns__IP(struct soap *soap, ns__IP *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__IP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__UsersList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__User(soap, &this->ns__UsersList::usersListUsers);
	this->ns__UsersList::usersListError.ns__ErrorCode::soap_default(soap);
}

void ns__UsersList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__User(soap, &this->ns__UsersList::usersListUsers);
	this->ns__UsersList::usersListError.soap_serialize(soap);
#endif
}

int ns__UsersList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__UsersList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UsersList(struct soap *soap, const char *tag, int id, const ns__UsersList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UsersList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__User(soap, "usersListUsers", -1, &a->ns__UsersList::usersListUsers, ""))
		return soap->error;
	if ((a->ns__UsersList::usersListError).soap_out(soap, "usersListError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__UsersList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__UsersList(soap, tag, this, type);
}

SOAP_FMAC3 ns__UsersList * SOAP_FMAC4 soap_in_ns__UsersList(struct soap *soap, const char *tag, ns__UsersList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__UsersList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UsersList, sizeof(ns__UsersList), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_usersListError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__User(soap, "usersListUsers", &a->ns__UsersList::usersListUsers, "ns:User"))
					continue;
			if (soap_flag_usersListError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__UsersList::usersListError).soap_in(soap, "usersListError", "ns:ErrorCode"))
				{	soap_flag_usersListError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_usersListError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__UsersList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UsersList, SOAP_TYPE_ns__UsersList, sizeof(ns__UsersList), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__UsersList * SOAP_FMAC2 soap_instantiate_ns__UsersList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UsersList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__UsersList *p;
	size_t k = sizeof(ns__UsersList);
	if (n < 0)
	{	p = SOAP_NEW(ns__UsersList);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__UsersList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__UsersList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UsersList, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__UsersList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:UsersList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__UsersList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__UsersList(soap, this, tag, type);
}

SOAP_FMAC3 ns__UsersList * SOAP_FMAC4 soap_get_ns__UsersList(struct soap *soap, ns__UsersList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UsersList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__User::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__User::userId = 0;
	this->ns__User::userName = "";
	this->ns__User::userPassword = "";
	this->ns__User::userNewPassword = "";
	this->ns__User::userFirstName = "";
	this->ns__User::userLastName = "";
	this->ns__User::userType = (enum ns__UserType)2;
	this->ns__User::userKey = "";
	soap_default_xsd__dateTime(soap, &this->ns__User::userSubmitDateTime);
	this->ns__User::userError.ns__ErrorCode::soap_default(soap);
}

void ns__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__User::userName);
	soap_serialize_xsd__string(soap, &this->ns__User::userPassword);
	soap_serialize_xsd__string(soap, &this->ns__User::userNewPassword);
	soap_serialize_xsd__string(soap, &this->ns__User::userFirstName);
	soap_serialize_xsd__string(soap, &this->ns__User::userLastName);
	soap_serialize_xsd__string(soap, &this->ns__User::userKey);
	soap_serialize_xsd__dateTime(soap, &this->ns__User::userSubmitDateTime);
	this->ns__User::userError.soap_serialize(soap);
#endif
}

int ns__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__User(struct soap *soap, const char *tag, int id, const ns__User *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__User), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "userId", -1, &a->ns__User::userId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userName", -1, &a->ns__User::userName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userPassword", -1, &a->ns__User::userPassword, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userNewPassword", -1, &a->ns__User::userNewPassword, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userFirstName", -1, &a->ns__User::userFirstName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userLastName", -1, &a->ns__User::userLastName, ""))
		return soap->error;
	if (soap_out_ns__UserType(soap, "userType", -1, &a->ns__User::userType, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userKey", -1, &a->ns__User::userKey, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "userSubmitDateTime", -1, &a->ns__User::userSubmitDateTime, ""))
		return soap->error;
	if ((a->ns__User::userError).soap_out(soap, "userError", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__User::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__User(soap, tag, this, type);
}

SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_in_ns__User(struct soap *soap, const char *tag, ns__User *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__User *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__User, sizeof(ns__User), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_userPassword1 = 1;
	size_t soap_flag_userNewPassword1 = 1;
	size_t soap_flag_userFirstName1 = 1;
	size_t soap_flag_userLastName1 = 1;
	size_t soap_flag_userType1 = 1;
	size_t soap_flag_userKey1 = 1;
	size_t soap_flag_userSubmitDateTime1 = 1;
	size_t soap_flag_userError1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "userId", &a->ns__User::userId, "xsd:int"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userName", &a->ns__User::userName, "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_userPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userPassword", &a->ns__User::userPassword, "xsd:string"))
				{	soap_flag_userPassword1--;
					continue;
				}
			if (soap_flag_userNewPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userNewPassword", &a->ns__User::userNewPassword, "xsd:string"))
				{	soap_flag_userNewPassword1--;
					continue;
				}
			if (soap_flag_userFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userFirstName", &a->ns__User::userFirstName, "xsd:string"))
				{	soap_flag_userFirstName1--;
					continue;
				}
			if (soap_flag_userLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userLastName", &a->ns__User::userLastName, "xsd:string"))
				{	soap_flag_userLastName1--;
					continue;
				}
			if (soap_flag_userType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__UserType(soap, "userType", &a->ns__User::userType, "ns:UserType"))
				{	soap_flag_userType1--;
					continue;
				}
			if (soap_flag_userKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userKey", &a->ns__User::userKey, "xsd:string"))
				{	soap_flag_userKey1--;
					continue;
				}
			if (soap_flag_userSubmitDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "userSubmitDateTime", &a->ns__User::userSubmitDateTime, "xsd:dateTime"))
				{	soap_flag_userSubmitDateTime1--;
					continue;
				}
			if (soap_flag_userError1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__User::userError).soap_in(soap, "userError", "ns:ErrorCode"))
				{	soap_flag_userError1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userSubmitDateTime1 > 0 || soap_flag_userError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__User, SOAP_TYPE_ns__User, sizeof(ns__User), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__User * SOAP_FMAC2 soap_instantiate_ns__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__User(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__User *p;
	size_t k = sizeof(ns__User);
	if (n < 0)
	{	p = SOAP_NEW(ns__User);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__User, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__User location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__User, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:User", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__User(soap, this, tag, type);
}

SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_get_ns__User(struct soap *soap, ns__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ErrorCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ErrorCode::errorNumber = 0;
	this->ns__ErrorCode::errorMessage = "";
	this->ns__ErrorCode::errorType = (enum ns__SettingLevel)0;
}

void ns__ErrorCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__ErrorCode::errorMessage);
#endif
}

int ns__ErrorCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ErrorCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ErrorCode(struct soap *soap, const char *tag, int id, const ns__ErrorCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "errorNumber", -1, &a->ns__ErrorCode::errorNumber, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "errorMessage", -1, &a->ns__ErrorCode::errorMessage, ""))
		return soap->error;
	if (soap_out_ns__SettingLevel(soap, "errorType", -1, &a->ns__ErrorCode::errorType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ErrorCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ErrorCode(soap, tag, this, type);
}

SOAP_FMAC3 ns__ErrorCode * SOAP_FMAC4 soap_in_ns__ErrorCode(struct soap *soap, const char *tag, ns__ErrorCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ErrorCode, sizeof(ns__ErrorCode), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_errorNumber1 = 1;
	size_t soap_flag_errorMessage1 = 1;
	size_t soap_flag_errorType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_errorNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "errorNumber", &a->ns__ErrorCode::errorNumber, "xsd:int"))
				{	soap_flag_errorNumber1--;
					continue;
				}
			if (soap_flag_errorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "errorMessage", &a->ns__ErrorCode::errorMessage, "xsd:string"))
				{	soap_flag_errorMessage1--;
					continue;
				}
			if (soap_flag_errorType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__SettingLevel(soap, "errorType", &a->ns__ErrorCode::errorType, "ns:SettingLevel"))
				{	soap_flag_errorType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ErrorCode, SOAP_TYPE_ns__ErrorCode, sizeof(ns__ErrorCode), 0, Server_Soap_finsert, Server_Soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ErrorCode * SOAP_FMAC2 soap_instantiate_ns__ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ErrorCode(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ErrorCode *p;
	size_t k = sizeof(ns__ErrorCode);
	if (n < 0)
	{	p = SOAP_NEW(ns__ErrorCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ErrorCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ErrorCode location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ErrorCode, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ErrorCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns:ErrorCode", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ErrorCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ErrorCode(soap, this, tag, type);
}

SOAP_FMAC3 ns__ErrorCode * SOAP_FMAC4 soap_get_ns__ErrorCode(struct soap *soap, ns__ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__string, sizeof(std::string), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__string, sizeof(std::string), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase), 0, SOAP_TYPE_xsd__string, SOAP_TYPE_xsd__string, sizeof(std::string), 0, Server_Soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__string(soap, tag?tag:"xsd:string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, Server_Soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_ENV__Fault::SOAP_ENV__Fault()
{
	soap_default_SOAP_ENV__Fault(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Reason::SOAP_ENV__Reason()
{
	soap_default_SOAP_ENV__Reason(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Detail::SOAP_ENV__Detail()
{
	soap_default_SOAP_ENV__Detail(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Code::SOAP_ENV__Code()
{
	soap_default_SOAP_ENV__Code(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Header::SOAP_ENV__Header()
{
	soap_default_SOAP_ENV__Header(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

ns__TestWorld::ns__TestWorld()
{
	soap_default_ns__TestWorld(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__TestWorld(struct soap *soap, struct ns__TestWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__dateTime(soap, &a->requestUserInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__TestWorld(struct soap *soap, const struct ns__TestWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__dateTime(soap, &a->requestUserInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__TestWorld(struct soap *soap, const char *tag, int id, const struct ns__TestWorld *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__TestWorld), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "requestUserInfo", -1, &a->requestUserInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__TestWorld * SOAP_FMAC4 soap_in_ns__TestWorld(struct soap *soap, const char *tag, struct ns__TestWorld *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__TestWorld *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__TestWorld, sizeof(struct ns__TestWorld), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__TestWorld(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "requestUserInfo", &a->requestUserInfo, "xsd:dateTime"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__TestWorld *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__TestWorld, SOAP_TYPE_ns__TestWorld, sizeof(struct ns__TestWorld), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__TestWorld * SOAP_FMAC2 soap_instantiate_ns__TestWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__TestWorld(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__TestWorld *p;
	size_t k = sizeof(struct ns__TestWorld);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__TestWorld);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__TestWorld, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__TestWorld location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__TestWorld, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__TestWorld(struct soap *soap, const struct ns__TestWorld *a, const char *tag, const char *type)
{
	if (soap_out_ns__TestWorld(soap, tag?tag:"ns:TestWorld", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__TestWorld * SOAP_FMAC4 soap_get_ns__TestWorld(struct soap *soap, struct ns__TestWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__TestWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__TestWorldResponse::ns__TestWorldResponse()
{
	soap_default_ns__TestWorldResponse(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__TestWorldResponse(struct soap *soap, struct ns__TestWorldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__dateTime(soap, &a->responseErrorInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__TestWorldResponse(struct soap *soap, const struct ns__TestWorldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__dateTime(soap, &a->responseErrorInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__TestWorldResponse(struct soap *soap, const char *tag, int id, const struct ns__TestWorldResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__TestWorldResponse), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "responseErrorInfo", -1, &a->responseErrorInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__TestWorldResponse * SOAP_FMAC4 soap_in_ns__TestWorldResponse(struct soap *soap, const char *tag, struct ns__TestWorldResponse *a, const char *type)
{
	size_t soap_flag_responseErrorInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__TestWorldResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__TestWorldResponse, sizeof(struct ns__TestWorldResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__TestWorldResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseErrorInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "responseErrorInfo", &a->responseErrorInfo, "xsd:dateTime"))
				{	soap_flag_responseErrorInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseErrorInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__TestWorldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__TestWorldResponse, SOAP_TYPE_ns__TestWorldResponse, sizeof(struct ns__TestWorldResponse), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__TestWorldResponse * SOAP_FMAC2 soap_instantiate_ns__TestWorldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__TestWorldResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__TestWorldResponse *p;
	size_t k = sizeof(struct ns__TestWorldResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__TestWorldResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__TestWorldResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__TestWorldResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__TestWorldResponse, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__TestWorldResponse(struct soap *soap, const struct ns__TestWorldResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__TestWorldResponse(soap, tag?tag:"ns:TestWorldResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__TestWorldResponse * SOAP_FMAC4 soap_get_ns__TestWorldResponse(struct soap *soap, struct ns__TestWorldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__TestWorldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__ChangeDeviceName::ns__ChangeDeviceName()
{
	soap_default_ns__ChangeDeviceName(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeDeviceName(struct soap *soap, struct ns__ChangeDeviceName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	soap_default_xsd__int(soap, &a->deviceSerialNumber);
	soap_default_xsd__string(soap, &a->newCityName);
	soap_default_xsd__string(soap, &a->newLocationName);
	soap_default_xsd__string(soap, &a->newDeviceName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeDeviceName(struct soap *soap, const struct ns__ChangeDeviceName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &a->newCityName);
	soap_serialize_xsd__string(soap, &a->newLocationName);
	soap_serialize_xsd__string(soap, &a->newDeviceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeDeviceName(struct soap *soap, const char *tag, int id, const struct ns__ChangeDeviceName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ChangeDeviceName), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "deviceSerialNumber", -1, &a->deviceSerialNumber, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newCityName", -1, &a->newCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newLocationName", -1, &a->newLocationName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newDeviceName", -1, &a->newDeviceName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ChangeDeviceName * SOAP_FMAC4 soap_in_ns__ChangeDeviceName(struct soap *soap, const char *tag, struct ns__ChangeDeviceName *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_deviceSerialNumber = 1;
	size_t soap_flag_newCityName = 1;
	size_t soap_flag_newLocationName = 1;
	size_t soap_flag_newDeviceName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ChangeDeviceName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ChangeDeviceName, sizeof(struct ns__ChangeDeviceName), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__ChangeDeviceName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_deviceSerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "deviceSerialNumber", &a->deviceSerialNumber, "xsd:int"))
				{	soap_flag_deviceSerialNumber--;
					continue;
				}
			if (soap_flag_newCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "newCityName", &a->newCityName, "xsd:string"))
				{	soap_flag_newCityName--;
					continue;
				}
			if (soap_flag_newLocationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "newLocationName", &a->newLocationName, "xsd:string"))
				{	soap_flag_newLocationName--;
					continue;
				}
			if (soap_flag_newDeviceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "newDeviceName", &a->newDeviceName, "xsd:string"))
				{	soap_flag_newDeviceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_deviceSerialNumber > 0 || soap_flag_newCityName > 0 || soap_flag_newLocationName > 0 || soap_flag_newDeviceName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__ChangeDeviceName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ChangeDeviceName, SOAP_TYPE_ns__ChangeDeviceName, sizeof(struct ns__ChangeDeviceName), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__ChangeDeviceName * SOAP_FMAC2 soap_instantiate_ns__ChangeDeviceName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ChangeDeviceName(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__ChangeDeviceName *p;
	size_t k = sizeof(struct ns__ChangeDeviceName);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__ChangeDeviceName);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__ChangeDeviceName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__ChangeDeviceName location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ChangeDeviceName, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeDeviceName(struct soap *soap, const struct ns__ChangeDeviceName *a, const char *tag, const char *type)
{
	if (soap_out_ns__ChangeDeviceName(soap, tag?tag:"ns:ChangeDeviceName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__ChangeDeviceName * SOAP_FMAC4 soap_get_ns__ChangeDeviceName(struct soap *soap, struct ns__ChangeDeviceName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ChangeDeviceName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__ChangeLocationName::ns__ChangeLocationName()
{
	soap_default_ns__ChangeLocationName(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeLocationName(struct soap *soap, struct ns__ChangeLocationName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	soap_default_xsd__string(soap, &a->oldCityName);
	soap_default_xsd__string(soap, &a->newCityName);
	soap_default_xsd__string(soap, &a->oldLocationName);
	soap_default_xsd__string(soap, &a->newLocationName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeLocationName(struct soap *soap, const struct ns__ChangeLocationName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &a->oldCityName);
	soap_serialize_xsd__string(soap, &a->newCityName);
	soap_serialize_xsd__string(soap, &a->oldLocationName);
	soap_serialize_xsd__string(soap, &a->newLocationName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeLocationName(struct soap *soap, const char *tag, int id, const struct ns__ChangeLocationName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ChangeLocationName), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "oldCityName", -1, &a->oldCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newCityName", -1, &a->newCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "oldLocationName", -1, &a->oldLocationName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newLocationName", -1, &a->newLocationName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ChangeLocationName * SOAP_FMAC4 soap_in_ns__ChangeLocationName(struct soap *soap, const char *tag, struct ns__ChangeLocationName *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_oldCityName = 1;
	size_t soap_flag_newCityName = 1;
	size_t soap_flag_oldLocationName = 1;
	size_t soap_flag_newLocationName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ChangeLocationName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ChangeLocationName, sizeof(struct ns__ChangeLocationName), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__ChangeLocationName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_oldCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "oldCityName", &a->oldCityName, "xsd:string"))
				{	soap_flag_oldCityName--;
					continue;
				}
			if (soap_flag_newCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "newCityName", &a->newCityName, "xsd:string"))
				{	soap_flag_newCityName--;
					continue;
				}
			if (soap_flag_oldLocationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "oldLocationName", &a->oldLocationName, "xsd:string"))
				{	soap_flag_oldLocationName--;
					continue;
				}
			if (soap_flag_newLocationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "newLocationName", &a->newLocationName, "xsd:string"))
				{	soap_flag_newLocationName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_oldCityName > 0 || soap_flag_newCityName > 0 || soap_flag_oldLocationName > 0 || soap_flag_newLocationName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__ChangeLocationName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ChangeLocationName, SOAP_TYPE_ns__ChangeLocationName, sizeof(struct ns__ChangeLocationName), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__ChangeLocationName * SOAP_FMAC2 soap_instantiate_ns__ChangeLocationName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ChangeLocationName(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__ChangeLocationName *p;
	size_t k = sizeof(struct ns__ChangeLocationName);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__ChangeLocationName);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__ChangeLocationName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__ChangeLocationName location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ChangeLocationName, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeLocationName(struct soap *soap, const struct ns__ChangeLocationName *a, const char *tag, const char *type)
{
	if (soap_out_ns__ChangeLocationName(soap, tag?tag:"ns:ChangeLocationName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__ChangeLocationName * SOAP_FMAC4 soap_get_ns__ChangeLocationName(struct soap *soap, struct ns__ChangeLocationName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ChangeLocationName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__ChangeCityName::ns__ChangeCityName()
{
	soap_default_ns__ChangeCityName(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeCityName(struct soap *soap, struct ns__ChangeCityName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	soap_default_xsd__string(soap, &a->oldCityName);
	soap_default_xsd__string(soap, &a->newCityName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeCityName(struct soap *soap, const struct ns__ChangeCityName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &a->oldCityName);
	soap_serialize_xsd__string(soap, &a->newCityName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeCityName(struct soap *soap, const char *tag, int id, const struct ns__ChangeCityName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ChangeCityName), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "oldCityName", -1, &a->oldCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newCityName", -1, &a->newCityName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ChangeCityName * SOAP_FMAC4 soap_in_ns__ChangeCityName(struct soap *soap, const char *tag, struct ns__ChangeCityName *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_oldCityName = 1;
	size_t soap_flag_newCityName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ChangeCityName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ChangeCityName, sizeof(struct ns__ChangeCityName), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__ChangeCityName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_oldCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "oldCityName", &a->oldCityName, "xsd:string"))
				{	soap_flag_oldCityName--;
					continue;
				}
			if (soap_flag_newCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "newCityName", &a->newCityName, "xsd:string"))
				{	soap_flag_newCityName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_oldCityName > 0 || soap_flag_newCityName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__ChangeCityName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ChangeCityName, SOAP_TYPE_ns__ChangeCityName, sizeof(struct ns__ChangeCityName), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__ChangeCityName * SOAP_FMAC2 soap_instantiate_ns__ChangeCityName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ChangeCityName(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__ChangeCityName *p;
	size_t k = sizeof(struct ns__ChangeCityName);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__ChangeCityName);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__ChangeCityName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__ChangeCityName location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ChangeCityName, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeCityName(struct soap *soap, const struct ns__ChangeCityName *a, const char *tag, const char *type)
{
	if (soap_out_ns__ChangeCityName(soap, tag?tag:"ns:ChangeCityName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__ChangeCityName * SOAP_FMAC4 soap_get_ns__ChangeCityName(struct soap *soap, struct ns__ChangeCityName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ChangeCityName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetCityAndLocations::ns__GetCityAndLocations()
{
	soap_default_ns__GetCityAndLocations(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetCityAndLocations(struct soap *soap, struct ns__GetCityAndLocations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetCityAndLocations(struct soap *soap, const struct ns__GetCityAndLocations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetCityAndLocations(struct soap *soap, const char *tag, int id, const struct ns__GetCityAndLocations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetCityAndLocations), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetCityAndLocations * SOAP_FMAC4 soap_in_ns__GetCityAndLocations(struct soap *soap, const char *tag, struct ns__GetCityAndLocations *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetCityAndLocations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetCityAndLocations, sizeof(struct ns__GetCityAndLocations), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetCityAndLocations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetCityAndLocations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetCityAndLocations, SOAP_TYPE_ns__GetCityAndLocations, sizeof(struct ns__GetCityAndLocations), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetCityAndLocations * SOAP_FMAC2 soap_instantiate_ns__GetCityAndLocations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetCityAndLocations(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetCityAndLocations *p;
	size_t k = sizeof(struct ns__GetCityAndLocations);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetCityAndLocations);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetCityAndLocations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetCityAndLocations location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetCityAndLocations, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetCityAndLocations(struct soap *soap, const struct ns__GetCityAndLocations *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetCityAndLocations(soap, tag?tag:"ns:GetCityAndLocations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetCityAndLocations * SOAP_FMAC4 soap_get_ns__GetCityAndLocations(struct soap *soap, struct ns__GetCityAndLocations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetCityAndLocations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__SetServerOptions::ns__SetServerOptions()
{
	soap_default_ns__SetServerOptions(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetServerOptions(struct soap *soap, struct ns__SetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->serverOptions.ns__ServerOptions::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetServerOptions(struct soap *soap, const struct ns__SetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->serverOptions.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetServerOptions(struct soap *soap, const char *tag, int id, const struct ns__SetServerOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetServerOptions), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->serverOptions.soap_out(soap, "serverOptions", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetServerOptions * SOAP_FMAC4 soap_in_ns__SetServerOptions(struct soap *soap, const char *tag, struct ns__SetServerOptions *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_serverOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetServerOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetServerOptions, sizeof(struct ns__SetServerOptions), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetServerOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_serverOptions && soap->error == SOAP_TAG_MISMATCH)
				if (a->serverOptions.soap_in(soap, "serverOptions", "ns:ServerOptions"))
				{	soap_flag_serverOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_serverOptions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetServerOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetServerOptions, SOAP_TYPE_ns__SetServerOptions, sizeof(struct ns__SetServerOptions), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetServerOptions * SOAP_FMAC2 soap_instantiate_ns__SetServerOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetServerOptions(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetServerOptions *p;
	size_t k = sizeof(struct ns__SetServerOptions);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetServerOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetServerOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetServerOptions location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetServerOptions, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetServerOptions(struct soap *soap, const struct ns__SetServerOptions *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetServerOptions(soap, tag?tag:"ns:SetServerOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetServerOptions * SOAP_FMAC4 soap_get_ns__SetServerOptions(struct soap *soap, struct ns__SetServerOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetServerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetServerOptions::ns__GetServerOptions()
{
	soap_default_ns__GetServerOptions(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetServerOptions(struct soap *soap, struct ns__GetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetServerOptions(struct soap *soap, const struct ns__GetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetServerOptions(struct soap *soap, const char *tag, int id, const struct ns__GetServerOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetServerOptions), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetServerOptions * SOAP_FMAC4 soap_in_ns__GetServerOptions(struct soap *soap, const char *tag, struct ns__GetServerOptions *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetServerOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetServerOptions, sizeof(struct ns__GetServerOptions), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetServerOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetServerOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetServerOptions, SOAP_TYPE_ns__GetServerOptions, sizeof(struct ns__GetServerOptions), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetServerOptions * SOAP_FMAC2 soap_instantiate_ns__GetServerOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetServerOptions(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetServerOptions *p;
	size_t k = sizeof(struct ns__GetServerOptions);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetServerOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetServerOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetServerOptions location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetServerOptions, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetServerOptions(struct soap *soap, const struct ns__GetServerOptions *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetServerOptions(soap, tag?tag:"ns:GetServerOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetServerOptions * SOAP_FMAC4 soap_get_ns__GetServerOptions(struct soap *soap, struct ns__GetServerOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetServerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetDeviceStatusLog::ns__GetDeviceStatusLog()
{
	soap_default_ns__GetDeviceStatusLog(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceStatusLog(struct soap *soap, struct ns__GetDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestStatusLogInfo.ns__DeviceStatusInfo::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceStatusLog(struct soap *soap, const struct ns__GetDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestStatusLogInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceStatusLog(struct soap *soap, const char *tag, int id, const struct ns__GetDeviceStatusLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDeviceStatusLog), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestStatusLogInfo.soap_out(soap, "requestStatusLogInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDeviceStatusLog * SOAP_FMAC4 soap_in_ns__GetDeviceStatusLog(struct soap *soap, const char *tag, struct ns__GetDeviceStatusLog *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestStatusLogInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDeviceStatusLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDeviceStatusLog, sizeof(struct ns__GetDeviceStatusLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDeviceStatusLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestStatusLogInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestStatusLogInfo.soap_in(soap, "requestStatusLogInfo", "ns:DeviceStatusInfo"))
				{	soap_flag_requestStatusLogInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestStatusLogInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDeviceStatusLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDeviceStatusLog, SOAP_TYPE_ns__GetDeviceStatusLog, sizeof(struct ns__GetDeviceStatusLog), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDeviceStatusLog * SOAP_FMAC2 soap_instantiate_ns__GetDeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDeviceStatusLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDeviceStatusLog *p;
	size_t k = sizeof(struct ns__GetDeviceStatusLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDeviceStatusLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDeviceStatusLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDeviceStatusLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDeviceStatusLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceStatusLog(struct soap *soap, const struct ns__GetDeviceStatusLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDeviceStatusLog(soap, tag?tag:"ns:GetDeviceStatusLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDeviceStatusLog * SOAP_FMAC4 soap_get_ns__GetDeviceStatusLog(struct soap *soap, struct ns__GetDeviceStatusLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDeviceStatusLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__SaveDeviceStatusLog::ns__SaveDeviceStatusLog()
{
	soap_default_ns__SaveDeviceStatusLog(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveDeviceStatusLog(struct soap *soap, struct ns__SaveDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestStatusLogInfo.ns__DeviceStatusLog::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveDeviceStatusLog(struct soap *soap, const struct ns__SaveDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestStatusLogInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveDeviceStatusLog(struct soap *soap, const char *tag, int id, const struct ns__SaveDeviceStatusLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SaveDeviceStatusLog), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestStatusLogInfo.soap_out(soap, "requestStatusLogInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SaveDeviceStatusLog * SOAP_FMAC4 soap_in_ns__SaveDeviceStatusLog(struct soap *soap, const char *tag, struct ns__SaveDeviceStatusLog *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestStatusLogInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SaveDeviceStatusLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SaveDeviceStatusLog, sizeof(struct ns__SaveDeviceStatusLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SaveDeviceStatusLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestStatusLogInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestStatusLogInfo.soap_in(soap, "requestStatusLogInfo", "ns:DeviceStatusLog"))
				{	soap_flag_requestStatusLogInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestStatusLogInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SaveDeviceStatusLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SaveDeviceStatusLog, SOAP_TYPE_ns__SaveDeviceStatusLog, sizeof(struct ns__SaveDeviceStatusLog), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SaveDeviceStatusLog * SOAP_FMAC2 soap_instantiate_ns__SaveDeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SaveDeviceStatusLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SaveDeviceStatusLog *p;
	size_t k = sizeof(struct ns__SaveDeviceStatusLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SaveDeviceStatusLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SaveDeviceStatusLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SaveDeviceStatusLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SaveDeviceStatusLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveDeviceStatusLog(struct soap *soap, const struct ns__SaveDeviceStatusLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__SaveDeviceStatusLog(soap, tag?tag:"ns:SaveDeviceStatusLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SaveDeviceStatusLog * SOAP_FMAC4 soap_get_ns__SaveDeviceStatusLog(struct soap *soap, struct ns__SaveDeviceStatusLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SaveDeviceStatusLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetUserLog::ns__GetUserLog()
{
	soap_default_ns__GetUserLog(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserLog(struct soap *soap, struct ns__GetUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestReportInfo.ns__Report::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserLog(struct soap *soap, const struct ns__GetUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestReportInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserLog(struct soap *soap, const char *tag, int id, const struct ns__GetUserLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserLog), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestReportInfo.soap_out(soap, "requestReportInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserLog * SOAP_FMAC4 soap_in_ns__GetUserLog(struct soap *soap, const char *tag, struct ns__GetUserLog *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestReportInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserLog, sizeof(struct ns__GetUserLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestReportInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestReportInfo.soap_in(soap, "requestReportInfo", "ns:Report"))
				{	soap_flag_requestReportInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestReportInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserLog, SOAP_TYPE_ns__GetUserLog, sizeof(struct ns__GetUserLog), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserLog * SOAP_FMAC2 soap_instantiate_ns__GetUserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserLog *p;
	size_t k = sizeof(struct ns__GetUserLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserLog(struct soap *soap, const struct ns__GetUserLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserLog(soap, tag?tag:"ns:GetUserLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserLog * SOAP_FMAC4 soap_get_ns__GetUserLog(struct soap *soap, struct ns__GetUserLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetUserLogResponse::ns__GetUserLogResponse()
{
	soap_default_ns__GetUserLogResponse(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserLogResponse(struct soap *soap, struct ns__GetUserLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__UserLog(soap, &a->responseActivityLogInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserLogResponse(struct soap *soap, const struct ns__GetUserLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__UserLog(soap, &a->responseActivityLogInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserLogResponse(struct soap *soap, const char *tag, int id, const struct ns__GetUserLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserLogResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__UserLog(soap, "responseActivityLogInfo", -1, &a->responseActivityLogInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserLogResponse * SOAP_FMAC4 soap_in_ns__GetUserLogResponse(struct soap *soap, const char *tag, struct ns__GetUserLogResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserLogResponse, sizeof(struct ns__GetUserLogResponse), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__UserLog(soap, "responseActivityLogInfo", &a->responseActivityLogInfo, "ns:UserLog"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseActivityLogInfo.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserLogResponse, SOAP_TYPE_ns__GetUserLogResponse, sizeof(struct ns__GetUserLogResponse), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserLogResponse * SOAP_FMAC2 soap_instantiate_ns__GetUserLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserLogResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserLogResponse *p;
	size_t k = sizeof(struct ns__GetUserLogResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserLogResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserLogResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserLogResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserLogResponse, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserLogResponse(struct soap *soap, const struct ns__GetUserLogResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserLogResponse(soap, tag?tag:"ns:GetUserLogResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserLogResponse * SOAP_FMAC4 soap_get_ns__GetUserLogResponse(struct soap *soap, struct ns__GetUserLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__SaveUserLog::ns__SaveUserLog()
{
	soap_default_ns__SaveUserLog(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveUserLog(struct soap *soap, struct ns__SaveUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestActivityLogInfo.ns__UserLog::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveUserLog(struct soap *soap, const struct ns__SaveUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestActivityLogInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveUserLog(struct soap *soap, const char *tag, int id, const struct ns__SaveUserLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SaveUserLog), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestActivityLogInfo.soap_out(soap, "requestActivityLogInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SaveUserLog * SOAP_FMAC4 soap_in_ns__SaveUserLog(struct soap *soap, const char *tag, struct ns__SaveUserLog *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestActivityLogInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SaveUserLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SaveUserLog, sizeof(struct ns__SaveUserLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SaveUserLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestActivityLogInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestActivityLogInfo.soap_in(soap, "requestActivityLogInfo", "ns:UserLog"))
				{	soap_flag_requestActivityLogInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestActivityLogInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SaveUserLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SaveUserLog, SOAP_TYPE_ns__SaveUserLog, sizeof(struct ns__SaveUserLog), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SaveUserLog * SOAP_FMAC2 soap_instantiate_ns__SaveUserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SaveUserLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SaveUserLog *p;
	size_t k = sizeof(struct ns__SaveUserLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SaveUserLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SaveUserLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SaveUserLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SaveUserLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveUserLog(struct soap *soap, const struct ns__SaveUserLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__SaveUserLog(soap, tag?tag:"ns:SaveUserLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SaveUserLog * SOAP_FMAC4 soap_get_ns__SaveUserLog(struct soap *soap, struct ns__SaveUserLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SaveUserLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetActivityLog::ns__GetActivityLog()
{
	soap_default_ns__GetActivityLog(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetActivityLog(struct soap *soap, struct ns__GetActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestReportInfo.ns__Report::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetActivityLog(struct soap *soap, const struct ns__GetActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestReportInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetActivityLog(struct soap *soap, const char *tag, int id, const struct ns__GetActivityLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetActivityLog), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestReportInfo.soap_out(soap, "requestReportInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetActivityLog * SOAP_FMAC4 soap_in_ns__GetActivityLog(struct soap *soap, const char *tag, struct ns__GetActivityLog *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestReportInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetActivityLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetActivityLog, sizeof(struct ns__GetActivityLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetActivityLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestReportInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestReportInfo.soap_in(soap, "requestReportInfo", "ns:Report"))
				{	soap_flag_requestReportInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestReportInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetActivityLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetActivityLog, SOAP_TYPE_ns__GetActivityLog, sizeof(struct ns__GetActivityLog), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetActivityLog * SOAP_FMAC2 soap_instantiate_ns__GetActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetActivityLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetActivityLog *p;
	size_t k = sizeof(struct ns__GetActivityLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetActivityLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetActivityLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetActivityLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetActivityLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetActivityLog(struct soap *soap, const struct ns__GetActivityLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetActivityLog(soap, tag?tag:"ns:GetActivityLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetActivityLog * SOAP_FMAC4 soap_get_ns__GetActivityLog(struct soap *soap, struct ns__GetActivityLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetActivityLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetActivityLogResponse::ns__GetActivityLogResponse()
{
	soap_default_ns__GetActivityLogResponse(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetActivityLogResponse(struct soap *soap, struct ns__GetActivityLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__ActivityLog(soap, &a->responseActivityLogInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetActivityLogResponse(struct soap *soap, const struct ns__GetActivityLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__ActivityLog(soap, &a->responseActivityLogInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetActivityLogResponse(struct soap *soap, const char *tag, int id, const struct ns__GetActivityLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetActivityLogResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__ActivityLog(soap, "responseActivityLogInfo", -1, &a->responseActivityLogInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetActivityLogResponse * SOAP_FMAC4 soap_in_ns__GetActivityLogResponse(struct soap *soap, const char *tag, struct ns__GetActivityLogResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetActivityLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetActivityLogResponse, sizeof(struct ns__GetActivityLogResponse), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetActivityLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__ActivityLog(soap, "responseActivityLogInfo", &a->responseActivityLogInfo, "ns:ActivityLog"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseActivityLogInfo.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetActivityLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetActivityLogResponse, SOAP_TYPE_ns__GetActivityLogResponse, sizeof(struct ns__GetActivityLogResponse), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetActivityLogResponse * SOAP_FMAC2 soap_instantiate_ns__GetActivityLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetActivityLogResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetActivityLogResponse *p;
	size_t k = sizeof(struct ns__GetActivityLogResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetActivityLogResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetActivityLogResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetActivityLogResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetActivityLogResponse, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetActivityLogResponse(struct soap *soap, const struct ns__GetActivityLogResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetActivityLogResponse(soap, tag?tag:"ns:GetActivityLogResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetActivityLogResponse * SOAP_FMAC4 soap_get_ns__GetActivityLogResponse(struct soap *soap, struct ns__GetActivityLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetActivityLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__SaveActivityLog::ns__SaveActivityLog()
{
	soap_default_ns__SaveActivityLog(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveActivityLog(struct soap *soap, struct ns__SaveActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestActivityLogInfo.ns__ActivityLog::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveActivityLog(struct soap *soap, const struct ns__SaveActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestActivityLogInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveActivityLog(struct soap *soap, const char *tag, int id, const struct ns__SaveActivityLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SaveActivityLog), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestActivityLogInfo.soap_out(soap, "requestActivityLogInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SaveActivityLog * SOAP_FMAC4 soap_in_ns__SaveActivityLog(struct soap *soap, const char *tag, struct ns__SaveActivityLog *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestActivityLogInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SaveActivityLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SaveActivityLog, sizeof(struct ns__SaveActivityLog), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SaveActivityLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestActivityLogInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestActivityLogInfo.soap_in(soap, "requestActivityLogInfo", "ns:ActivityLog"))
				{	soap_flag_requestActivityLogInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestActivityLogInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SaveActivityLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SaveActivityLog, SOAP_TYPE_ns__SaveActivityLog, sizeof(struct ns__SaveActivityLog), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SaveActivityLog * SOAP_FMAC2 soap_instantiate_ns__SaveActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SaveActivityLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SaveActivityLog *p;
	size_t k = sizeof(struct ns__SaveActivityLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SaveActivityLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SaveActivityLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SaveActivityLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SaveActivityLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveActivityLog(struct soap *soap, const struct ns__SaveActivityLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__SaveActivityLog(soap, tag?tag:"ns:SaveActivityLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SaveActivityLog * SOAP_FMAC4 soap_get_ns__SaveActivityLog(struct soap *soap, struct ns__SaveActivityLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SaveActivityLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetUserDevices::ns__GetUserDevices()
{
	soap_default_ns__GetUserDevices(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserDevices(struct soap *soap, struct ns__GetUserDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestSelectedUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserDevices(struct soap *soap, const struct ns__GetUserDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestSelectedUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserDevices(struct soap *soap, const char *tag, int id, const struct ns__GetUserDevices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserDevices), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestSelectedUserInfo.soap_out(soap, "requestSelectedUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserDevices * SOAP_FMAC4 soap_in_ns__GetUserDevices(struct soap *soap, const char *tag, struct ns__GetUserDevices *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestSelectedUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserDevices, sizeof(struct ns__GetUserDevices), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestSelectedUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestSelectedUserInfo.soap_in(soap, "requestSelectedUserInfo", "ns:User"))
				{	soap_flag_requestSelectedUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestSelectedUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserDevices, SOAP_TYPE_ns__GetUserDevices, sizeof(struct ns__GetUserDevices), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserDevices * SOAP_FMAC2 soap_instantiate_ns__GetUserDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserDevices(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserDevices *p;
	size_t k = sizeof(struct ns__GetUserDevices);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserDevices);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserDevices, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserDevices location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserDevices, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserDevices(struct soap *soap, const struct ns__GetUserDevices *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserDevices(soap, tag?tag:"ns:GetUserDevices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserDevices * SOAP_FMAC4 soap_get_ns__GetUserDevices(struct soap *soap, struct ns__GetUserDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__DeleteDeviceFromUserList::ns__DeleteDeviceFromUserList()
{
	soap_default_ns__DeleteDeviceFromUserList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteDeviceFromUserList(struct soap *soap, struct ns__DeleteDeviceFromUserList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestUserDeviceInfo.ns__UserDevice::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteDeviceFromUserList(struct soap *soap, const struct ns__DeleteDeviceFromUserList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestUserDeviceInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteDeviceFromUserList(struct soap *soap, const char *tag, int id, const struct ns__DeleteDeviceFromUserList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeleteDeviceFromUserList), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestUserDeviceInfo.soap_out(soap, "requestUserDeviceInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeleteDeviceFromUserList * SOAP_FMAC4 soap_in_ns__DeleteDeviceFromUserList(struct soap *soap, const char *tag, struct ns__DeleteDeviceFromUserList *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestUserDeviceInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeleteDeviceFromUserList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeleteDeviceFromUserList, sizeof(struct ns__DeleteDeviceFromUserList), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__DeleteDeviceFromUserList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestUserDeviceInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserDeviceInfo.soap_in(soap, "requestUserDeviceInfo", "ns:UserDevice"))
				{	soap_flag_requestUserDeviceInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestUserDeviceInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__DeleteDeviceFromUserList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeleteDeviceFromUserList, SOAP_TYPE_ns__DeleteDeviceFromUserList, sizeof(struct ns__DeleteDeviceFromUserList), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__DeleteDeviceFromUserList * SOAP_FMAC2 soap_instantiate_ns__DeleteDeviceFromUserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeleteDeviceFromUserList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__DeleteDeviceFromUserList *p;
	size_t k = sizeof(struct ns__DeleteDeviceFromUserList);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__DeleteDeviceFromUserList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__DeleteDeviceFromUserList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__DeleteDeviceFromUserList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeleteDeviceFromUserList, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteDeviceFromUserList(struct soap *soap, const struct ns__DeleteDeviceFromUserList *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeleteDeviceFromUserList(soap, tag?tag:"ns:DeleteDeviceFromUserList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__DeleteDeviceFromUserList * SOAP_FMAC4 soap_get_ns__DeleteDeviceFromUserList(struct soap *soap, struct ns__DeleteDeviceFromUserList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeleteDeviceFromUserList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__AssignDeviceToUser::ns__AssignDeviceToUser()
{
	soap_default_ns__AssignDeviceToUser(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AssignDeviceToUser(struct soap *soap, struct ns__AssignDeviceToUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestUserDeviceInfo.ns__UserDevice::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AssignDeviceToUser(struct soap *soap, const struct ns__AssignDeviceToUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestUserDeviceInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AssignDeviceToUser(struct soap *soap, const char *tag, int id, const struct ns__AssignDeviceToUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AssignDeviceToUser), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestUserDeviceInfo.soap_out(soap, "requestUserDeviceInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AssignDeviceToUser * SOAP_FMAC4 soap_in_ns__AssignDeviceToUser(struct soap *soap, const char *tag, struct ns__AssignDeviceToUser *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestUserDeviceInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__AssignDeviceToUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AssignDeviceToUser, sizeof(struct ns__AssignDeviceToUser), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__AssignDeviceToUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestUserDeviceInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserDeviceInfo.soap_in(soap, "requestUserDeviceInfo", "ns:UserDevice"))
				{	soap_flag_requestUserDeviceInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestUserDeviceInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__AssignDeviceToUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AssignDeviceToUser, SOAP_TYPE_ns__AssignDeviceToUser, sizeof(struct ns__AssignDeviceToUser), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__AssignDeviceToUser * SOAP_FMAC2 soap_instantiate_ns__AssignDeviceToUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AssignDeviceToUser(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__AssignDeviceToUser *p;
	size_t k = sizeof(struct ns__AssignDeviceToUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__AssignDeviceToUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__AssignDeviceToUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__AssignDeviceToUser location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__AssignDeviceToUser, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AssignDeviceToUser(struct soap *soap, const struct ns__AssignDeviceToUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__AssignDeviceToUser(soap, tag?tag:"ns:AssignDeviceToUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__AssignDeviceToUser * SOAP_FMAC4 soap_get_ns__AssignDeviceToUser(struct soap *soap, struct ns__AssignDeviceToUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AssignDeviceToUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__DeleteUser::ns__DeleteUser()
{
	soap_default_ns__DeleteUser(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteUser(struct soap *soap, struct ns__DeleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestDeleteUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteUser(struct soap *soap, const struct ns__DeleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestDeleteUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteUser(struct soap *soap, const char *tag, int id, const struct ns__DeleteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeleteUser), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestDeleteUserInfo.soap_out(soap, "requestDeleteUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeleteUser * SOAP_FMAC4 soap_in_ns__DeleteUser(struct soap *soap, const char *tag, struct ns__DeleteUser *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestDeleteUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeleteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeleteUser, sizeof(struct ns__DeleteUser), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__DeleteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestDeleteUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestDeleteUserInfo.soap_in(soap, "requestDeleteUserInfo", "ns:User"))
				{	soap_flag_requestDeleteUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestDeleteUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__DeleteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeleteUser, SOAP_TYPE_ns__DeleteUser, sizeof(struct ns__DeleteUser), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__DeleteUser * SOAP_FMAC2 soap_instantiate_ns__DeleteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeleteUser(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__DeleteUser *p;
	size_t k = sizeof(struct ns__DeleteUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__DeleteUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__DeleteUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__DeleteUser location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeleteUser, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteUser(struct soap *soap, const struct ns__DeleteUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeleteUser(soap, tag?tag:"ns:DeleteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__DeleteUser * SOAP_FMAC4 soap_get_ns__DeleteUser(struct soap *soap, struct ns__DeleteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeleteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__UpdateUser::ns__UpdateUser()
{
	soap_default_ns__UpdateUser(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__UpdateUser(struct soap *soap, struct ns__UpdateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestNewUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__UpdateUser(struct soap *soap, const struct ns__UpdateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestNewUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UpdateUser(struct soap *soap, const char *tag, int id, const struct ns__UpdateUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UpdateUser), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestNewUserInfo.soap_out(soap, "requestNewUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__UpdateUser * SOAP_FMAC4 soap_in_ns__UpdateUser(struct soap *soap, const char *tag, struct ns__UpdateUser *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestNewUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__UpdateUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UpdateUser, sizeof(struct ns__UpdateUser), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__UpdateUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestNewUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestNewUserInfo.soap_in(soap, "requestNewUserInfo", "ns:User"))
				{	soap_flag_requestNewUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestNewUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__UpdateUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UpdateUser, SOAP_TYPE_ns__UpdateUser, sizeof(struct ns__UpdateUser), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__UpdateUser * SOAP_FMAC2 soap_instantiate_ns__UpdateUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UpdateUser(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__UpdateUser *p;
	size_t k = sizeof(struct ns__UpdateUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__UpdateUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__UpdateUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__UpdateUser location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UpdateUser, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__UpdateUser(struct soap *soap, const struct ns__UpdateUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__UpdateUser(soap, tag?tag:"ns:UpdateUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__UpdateUser * SOAP_FMAC4 soap_get_ns__UpdateUser(struct soap *soap, struct ns__UpdateUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UpdateUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__AddUser::ns__AddUser()
{
	soap_default_ns__AddUser(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AddUser(struct soap *soap, struct ns__AddUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestNewUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AddUser(struct soap *soap, const struct ns__AddUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestNewUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AddUser(struct soap *soap, const char *tag, int id, const struct ns__AddUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AddUser), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestNewUserInfo.soap_out(soap, "requestNewUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AddUser * SOAP_FMAC4 soap_in_ns__AddUser(struct soap *soap, const char *tag, struct ns__AddUser *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestNewUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__AddUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AddUser, sizeof(struct ns__AddUser), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__AddUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestNewUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestNewUserInfo.soap_in(soap, "requestNewUserInfo", "ns:User"))
				{	soap_flag_requestNewUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestNewUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__AddUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AddUser, SOAP_TYPE_ns__AddUser, sizeof(struct ns__AddUser), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__AddUser * SOAP_FMAC2 soap_instantiate_ns__AddUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AddUser(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__AddUser *p;
	size_t k = sizeof(struct ns__AddUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__AddUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__AddUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__AddUser location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__AddUser, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AddUser(struct soap *soap, const struct ns__AddUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__AddUser(soap, tag?tag:"ns:AddUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__AddUser * SOAP_FMAC4 soap_get_ns__AddUser(struct soap *soap, struct ns__AddUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AddUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetUsersList::ns__GetUsersList()
{
	soap_default_ns__GetUsersList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUsersList(struct soap *soap, struct ns__GetUsersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUsersList(struct soap *soap, const struct ns__GetUsersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUsersList(struct soap *soap, const char *tag, int id, const struct ns__GetUsersList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUsersList), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUsersList * SOAP_FMAC4 soap_in_ns__GetUsersList(struct soap *soap, const char *tag, struct ns__GetUsersList *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUsersList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUsersList, sizeof(struct ns__GetUsersList), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUsersList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUsersList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUsersList, SOAP_TYPE_ns__GetUsersList, sizeof(struct ns__GetUsersList), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUsersList * SOAP_FMAC2 soap_instantiate_ns__GetUsersList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUsersList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUsersList *p;
	size_t k = sizeof(struct ns__GetUsersList);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUsersList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUsersList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUsersList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUsersList, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUsersList(struct soap *soap, const struct ns__GetUsersList *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUsersList(soap, tag?tag:"ns:GetUsersList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUsersList * SOAP_FMAC4 soap_get_ns__GetUsersList(struct soap *soap, struct ns__GetUsersList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUsersList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetAllDeviceList::ns__GetAllDeviceList()
{
	soap_default_ns__GetAllDeviceList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllDeviceList(struct soap *soap, struct ns__GetAllDeviceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllDeviceList(struct soap *soap, const struct ns__GetAllDeviceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllDeviceList(struct soap *soap, const char *tag, int id, const struct ns__GetAllDeviceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllDeviceList), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllDeviceList * SOAP_FMAC4 soap_in_ns__GetAllDeviceList(struct soap *soap, const char *tag, struct ns__GetAllDeviceList *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllDeviceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllDeviceList, sizeof(struct ns__GetAllDeviceList), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetAllDeviceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetAllDeviceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllDeviceList, SOAP_TYPE_ns__GetAllDeviceList, sizeof(struct ns__GetAllDeviceList), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetAllDeviceList * SOAP_FMAC2 soap_instantiate_ns__GetAllDeviceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllDeviceList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetAllDeviceList *p;
	size_t k = sizeof(struct ns__GetAllDeviceList);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetAllDeviceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetAllDeviceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetAllDeviceList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetAllDeviceList, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllDeviceList(struct soap *soap, const struct ns__GetAllDeviceList *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetAllDeviceList(soap, tag?tag:"ns:GetAllDeviceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetAllDeviceList * SOAP_FMAC4 soap_get_ns__GetAllDeviceList(struct soap *soap, struct ns__GetAllDeviceList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllDeviceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetUserDeviceList::ns__GetUserDeviceList()
{
	soap_default_ns__GetUserDeviceList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserDeviceList(struct soap *soap, struct ns__GetUserDeviceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserDeviceList(struct soap *soap, const struct ns__GetUserDeviceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserDeviceList(struct soap *soap, const char *tag, int id, const struct ns__GetUserDeviceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserDeviceList), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserDeviceList * SOAP_FMAC4 soap_in_ns__GetUserDeviceList(struct soap *soap, const char *tag, struct ns__GetUserDeviceList *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserDeviceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserDeviceList, sizeof(struct ns__GetUserDeviceList), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserDeviceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserDeviceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserDeviceList, SOAP_TYPE_ns__GetUserDeviceList, sizeof(struct ns__GetUserDeviceList), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserDeviceList * SOAP_FMAC2 soap_instantiate_ns__GetUserDeviceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserDeviceList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserDeviceList *p;
	size_t k = sizeof(struct ns__GetUserDeviceList);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserDeviceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserDeviceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserDeviceList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserDeviceList, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserDeviceList(struct soap *soap, const struct ns__GetUserDeviceList *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserDeviceList(soap, tag?tag:"ns:GetUserDeviceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserDeviceList * SOAP_FMAC4 soap_get_ns__GetUserDeviceList(struct soap *soap, struct ns__GetUserDeviceList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserDeviceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__Login::ns__Login()
{
	soap_default_ns__Login(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Login(struct soap *soap, struct ns__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Login(struct soap *soap, const struct ns__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Login(struct soap *soap, const char *tag, int id, const struct ns__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Login), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Login * SOAP_FMAC4 soap_in_ns__Login(struct soap *soap, const char *tag, struct ns__Login *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Login, sizeof(struct ns__Login), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__Login(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Login, SOAP_TYPE_ns__Login, sizeof(struct ns__Login), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__Login * SOAP_FMAC2 soap_instantiate_ns__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Login(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__Login *p;
	size_t k = sizeof(struct ns__Login);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__Login);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__Login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__Login location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Login, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Login(struct soap *soap, const struct ns__Login *a, const char *tag, const char *type)
{
	if (soap_out_ns__Login(soap, tag?tag:"ns:Login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Login * SOAP_FMAC4 soap_get_ns__Login(struct soap *soap, struct ns__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__DeleteDevices::ns__DeleteDevices()
{
	soap_default_ns__DeleteDevices(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteDevices(struct soap *soap, struct ns__DeleteDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	soap_default_std__vectorTemplateOfns__Device(soap, &a->requestDeviceList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteDevices(struct soap *soap, const struct ns__DeleteDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfns__Device(soap, &a->requestDeviceList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteDevices(struct soap *soap, const char *tag, int id, const struct ns__DeleteDevices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeleteDevices), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Device(soap, "requestDeviceList", -1, &a->requestDeviceList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeleteDevices * SOAP_FMAC4 soap_in_ns__DeleteDevices(struct soap *soap, const char *tag, struct ns__DeleteDevices *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeleteDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeleteDevices, sizeof(struct ns__DeleteDevices), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__DeleteDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__Device(soap, "requestDeviceList", &a->requestDeviceList, "ns:Device"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || a->requestDeviceList.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__DeleteDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeleteDevices, SOAP_TYPE_ns__DeleteDevices, sizeof(struct ns__DeleteDevices), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__DeleteDevices * SOAP_FMAC2 soap_instantiate_ns__DeleteDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeleteDevices(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__DeleteDevices *p;
	size_t k = sizeof(struct ns__DeleteDevices);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__DeleteDevices);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__DeleteDevices, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__DeleteDevices location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeleteDevices, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteDevices(struct soap *soap, const struct ns__DeleteDevices *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeleteDevices(soap, tag?tag:"ns:DeleteDevices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__DeleteDevices * SOAP_FMAC4 soap_get_ns__DeleteDevices(struct soap *soap, struct ns__DeleteDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeleteDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__SetAllDeviceSetting::ns__SetAllDeviceSetting()
{
	soap_default_ns__SetAllDeviceSetting(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAllDeviceSetting(struct soap *soap, struct ns__SetAllDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	soap_default_std__vectorTemplateOfns__Device(soap, &a->requestDeviceInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAllDeviceSetting(struct soap *soap, const struct ns__SetAllDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfns__Device(soap, &a->requestDeviceInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAllDeviceSetting(struct soap *soap, const char *tag, int id, const struct ns__SetAllDeviceSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetAllDeviceSetting), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Device(soap, "requestDeviceInfo", -1, &a->requestDeviceInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetAllDeviceSetting * SOAP_FMAC4 soap_in_ns__SetAllDeviceSetting(struct soap *soap, const char *tag, struct ns__SetAllDeviceSetting *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetAllDeviceSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetAllDeviceSetting, sizeof(struct ns__SetAllDeviceSetting), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetAllDeviceSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__Device(soap, "requestDeviceInfo", &a->requestDeviceInfo, "ns:Device"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || a->requestDeviceInfo.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetAllDeviceSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetAllDeviceSetting, SOAP_TYPE_ns__SetAllDeviceSetting, sizeof(struct ns__SetAllDeviceSetting), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetAllDeviceSetting * SOAP_FMAC2 soap_instantiate_ns__SetAllDeviceSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetAllDeviceSetting(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetAllDeviceSetting *p;
	size_t k = sizeof(struct ns__SetAllDeviceSetting);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetAllDeviceSetting);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetAllDeviceSetting, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetAllDeviceSetting location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetAllDeviceSetting, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAllDeviceSetting(struct soap *soap, const struct ns__SetAllDeviceSetting *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetAllDeviceSetting(soap, tag?tag:"ns:SetAllDeviceSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetAllDeviceSetting * SOAP_FMAC4 soap_get_ns__SetAllDeviceSetting(struct soap *soap, struct ns__SetAllDeviceSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetAllDeviceSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__SetAllDeviceSettingResponse::ns__SetAllDeviceSettingResponse()
{
	soap_default_ns__SetAllDeviceSettingResponse(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAllDeviceSettingResponse(struct soap *soap, struct ns__SetAllDeviceSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__ErrorCode(soap, &a->responseErrorInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAllDeviceSettingResponse(struct soap *soap, const struct ns__SetAllDeviceSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__ErrorCode(soap, &a->responseErrorInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAllDeviceSettingResponse(struct soap *soap, const char *tag, int id, const struct ns__SetAllDeviceSettingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetAllDeviceSettingResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__ErrorCode(soap, "responseErrorInfo", -1, &a->responseErrorInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC4 soap_in_ns__SetAllDeviceSettingResponse(struct soap *soap, const char *tag, struct ns__SetAllDeviceSettingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetAllDeviceSettingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetAllDeviceSettingResponse, sizeof(struct ns__SetAllDeviceSettingResponse), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetAllDeviceSettingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns__ErrorCode(soap, "responseErrorInfo", &a->responseErrorInfo, "ns:ErrorCode"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseErrorInfo.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetAllDeviceSettingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetAllDeviceSettingResponse, SOAP_TYPE_ns__SetAllDeviceSettingResponse, sizeof(struct ns__SetAllDeviceSettingResponse), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC2 soap_instantiate_ns__SetAllDeviceSettingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetAllDeviceSettingResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetAllDeviceSettingResponse *p;
	size_t k = sizeof(struct ns__SetAllDeviceSettingResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetAllDeviceSettingResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetAllDeviceSettingResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetAllDeviceSettingResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetAllDeviceSettingResponse, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAllDeviceSettingResponse(struct soap *soap, const struct ns__SetAllDeviceSettingResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetAllDeviceSettingResponse(soap, tag?tag:"ns:SetAllDeviceSettingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC4 soap_get_ns__SetAllDeviceSettingResponse(struct soap *soap, struct ns__SetAllDeviceSettingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetAllDeviceSettingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__SetDeviceSetting::ns__SetDeviceSetting()
{
	soap_default_ns__SetDeviceSetting(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetDeviceSetting(struct soap *soap, struct ns__SetDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestDeviceInfo.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetDeviceSetting(struct soap *soap, const struct ns__SetDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestDeviceInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetDeviceSetting(struct soap *soap, const char *tag, int id, const struct ns__SetDeviceSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetDeviceSetting), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestDeviceInfo.soap_out(soap, "requestDeviceInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetDeviceSetting * SOAP_FMAC4 soap_in_ns__SetDeviceSetting(struct soap *soap, const char *tag, struct ns__SetDeviceSetting *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestDeviceInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetDeviceSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetDeviceSetting, sizeof(struct ns__SetDeviceSetting), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetDeviceSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestDeviceInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestDeviceInfo.soap_in(soap, "requestDeviceInfo", "ns:Device"))
				{	soap_flag_requestDeviceInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestDeviceInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetDeviceSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetDeviceSetting, SOAP_TYPE_ns__SetDeviceSetting, sizeof(struct ns__SetDeviceSetting), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetDeviceSetting * SOAP_FMAC2 soap_instantiate_ns__SetDeviceSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetDeviceSetting(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetDeviceSetting *p;
	size_t k = sizeof(struct ns__SetDeviceSetting);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetDeviceSetting);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetDeviceSetting, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetDeviceSetting location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetDeviceSetting, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetDeviceSetting(struct soap *soap, const struct ns__SetDeviceSetting *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetDeviceSetting(soap, tag?tag:"ns:SetDeviceSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetDeviceSetting * SOAP_FMAC4 soap_get_ns__SetDeviceSetting(struct soap *soap, struct ns__SetDeviceSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetDeviceSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetAllDeviceStatus::ns__GetAllDeviceStatus()
{
	soap_default_ns__GetAllDeviceStatus(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllDeviceStatus(struct soap *soap, struct ns__GetAllDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllDeviceStatus(struct soap *soap, const struct ns__GetAllDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllDeviceStatus(struct soap *soap, const char *tag, int id, const struct ns__GetAllDeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllDeviceStatus), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllDeviceStatus * SOAP_FMAC4 soap_in_ns__GetAllDeviceStatus(struct soap *soap, const char *tag, struct ns__GetAllDeviceStatus *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllDeviceStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllDeviceStatus, sizeof(struct ns__GetAllDeviceStatus), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetAllDeviceStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetAllDeviceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllDeviceStatus, SOAP_TYPE_ns__GetAllDeviceStatus, sizeof(struct ns__GetAllDeviceStatus), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetAllDeviceStatus * SOAP_FMAC2 soap_instantiate_ns__GetAllDeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllDeviceStatus(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetAllDeviceStatus *p;
	size_t k = sizeof(struct ns__GetAllDeviceStatus);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetAllDeviceStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetAllDeviceStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetAllDeviceStatus location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetAllDeviceStatus, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllDeviceStatus(struct soap *soap, const struct ns__GetAllDeviceStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetAllDeviceStatus(soap, tag?tag:"ns:GetAllDeviceStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetAllDeviceStatus * SOAP_FMAC4 soap_get_ns__GetAllDeviceStatus(struct soap *soap, struct ns__GetAllDeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

ns__GetDeviceStatus::ns__GetDeviceStatus()
{
	soap_default_ns__GetDeviceStatus(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceStatus(struct soap *soap, struct ns__GetDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUserInfo.ns__User::soap_default(soap);
	a->requestDeviceInfo.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceStatus(struct soap *soap, const struct ns__GetDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUserInfo.soap_serialize(soap);
	a->requestDeviceInfo.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceStatus(struct soap *soap, const char *tag, int id, const struct ns__GetDeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDeviceStatus), type))
		return soap->error;
	if (a->requestUserInfo.soap_out(soap, "requestUserInfo", -1, ""))
		return soap->error;
	if (a->requestDeviceInfo.soap_out(soap, "requestDeviceInfo", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDeviceStatus * SOAP_FMAC4 soap_in_ns__GetDeviceStatus(struct soap *soap, const char *tag, struct ns__GetDeviceStatus *a, const char *type)
{
	size_t soap_flag_requestUserInfo = 1;
	size_t soap_flag_requestDeviceInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDeviceStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDeviceStatus, sizeof(struct ns__GetDeviceStatus), soap->type, soap->arrayType, Server_Soap_instantiate, Server_Soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDeviceStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestUserInfo.soap_in(soap, "requestUserInfo", "ns:User"))
				{	soap_flag_requestUserInfo--;
					continue;
				}
			if (soap_flag_requestDeviceInfo && soap->error == SOAP_TAG_MISMATCH)
				if (a->requestDeviceInfo.soap_in(soap, "requestDeviceInfo", "ns:Device"))
				{	soap_flag_requestDeviceInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUserInfo > 0 || soap_flag_requestDeviceInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDeviceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDeviceStatus, SOAP_TYPE_ns__GetDeviceStatus, sizeof(struct ns__GetDeviceStatus), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDeviceStatus * SOAP_FMAC2 soap_instantiate_ns__GetDeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDeviceStatus(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDeviceStatus *p;
	size_t k = sizeof(struct ns__GetDeviceStatus);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDeviceStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDeviceStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDeviceStatus location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDeviceStatus, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceStatus(struct soap *soap, const struct ns__GetDeviceStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDeviceStatus(soap, tag?tag:"ns:GetDeviceStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDeviceStatus * SOAP_FMAC4 soap_get_ns__GetDeviceStatus(struct soap *soap, struct ns__GetDeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct tm * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct tm *p;
	size_t k = sizeof(struct tm);
	if (n < 0)
	{	p = SOAP_NEW(struct tm);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct tm, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct tm location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__dateTime, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__dateTime(struct soap *soap, const struct tm *a, const char *tag, const char *type)
{
	if (soap_out_xsd__dateTime(soap, tag?tag:"xsd:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tm * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, struct tm *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tm(struct soap *soap, struct tm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tm_sec = 0;
	a->tm_min = 0;
	a->tm_hour = 0;
	a->tm_mday = 1;
	a->tm_mon = 0;
	a->tm_year = 1900;
	soap_default_int(soap, &a->tm_isdst);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tm(struct soap *soap, const struct tm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tm(struct soap *soap, const char *tag, int id, const struct tm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tm), type))
		return soap->error;
	if (soap_out_int(soap, "tm-sec", -1, &a->tm_sec, ""))
		return soap->error;
	if (soap_out_int(soap, "tm-min", -1, &a->tm_min, ""))
		return soap->error;
	if (soap_out_int(soap, "tm-hour", -1, &a->tm_hour, ""))
		return soap->error;
	if (soap_out_int(soap, "tm-mday", -1, &a->tm_mday, ""))
		return soap->error;
	if (soap_out_int(soap, "tm-mon", -1, &a->tm_mon, ""))
		return soap->error;
	if (soap_out_int(soap, "tm-year", -1, &a->tm_year, ""))
		return soap->error;
	if (soap_out_int(soap, "tm-isdst", -1, &a->tm_isdst, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tm * SOAP_FMAC4 soap_in_tm(struct soap *soap, const char *tag, struct tm *a, const char *type)
{
	size_t soap_flag_tm_sec = 1;
	size_t soap_flag_tm_min = 1;
	size_t soap_flag_tm_hour = 1;
	size_t soap_flag_tm_mday = 1;
	size_t soap_flag_tm_mon = 1;
	size_t soap_flag_tm_year = 1;
	size_t soap_flag_tm_isdst = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tm, sizeof(struct tm), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tm(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tm_sec && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tm-sec", &a->tm_sec, "xsd:int"))
				{	soap_flag_tm_sec--;
					continue;
				}
			if (soap_flag_tm_min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tm-min", &a->tm_min, "xsd:int"))
				{	soap_flag_tm_min--;
					continue;
				}
			if (soap_flag_tm_hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tm-hour", &a->tm_hour, "xsd:int"))
				{	soap_flag_tm_hour--;
					continue;
				}
			if (soap_flag_tm_mday && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tm-mday", &a->tm_mday, "xsd:int"))
				{	soap_flag_tm_mday--;
					continue;
				}
			if (soap_flag_tm_mon && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tm-mon", &a->tm_mon, "xsd:int"))
				{	soap_flag_tm_mon--;
					continue;
				}
			if (soap_flag_tm_year && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tm-year", &a->tm_year, "xsd:int"))
				{	soap_flag_tm_year--;
					continue;
				}
			if (soap_flag_tm_isdst && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tm-isdst", &a->tm_isdst, "xsd:int"))
				{	soap_flag_tm_isdst--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tm_isdst > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tm, SOAP_TYPE_tm, sizeof(struct tm), 0, Server_Soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct tm * SOAP_FMAC2 soap_instantiate_tm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tm(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct tm *p;
	size_t k = sizeof(struct tm);
	if (n < 0)
	{	p = SOAP_NEW(struct tm);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct tm, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct tm location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_tm, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tm(struct soap *soap, const struct tm *a, const char *tag, const char *type)
{
	if (soap_out_tm(soap, tag?tag:"tm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tm * SOAP_FMAC4 soap_get_tm(struct soap *soap, struct tm *p, const char *tag, const char *type)
{
	if ((p = soap_in_tm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__UserLog(struct soap *soap, std::vector<ns__UserLog> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__UserLog(struct soap *soap, const std::vector<ns__UserLog> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__UserLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__UserLog(struct soap *soap, const char *tag, int id, const std::vector<ns__UserLog> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__UserLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__UserLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__UserLog(struct soap *soap, const char *tag, std::vector<ns__UserLog> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__UserLog(soap)))
			return NULL;
		ns__UserLog n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__UserLog, SOAP_TYPE_std__vectorTemplateOfns__UserLog, sizeof(ns__UserLog), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__UserLog(soap, tag, NULL, "ns:UserLog"))
				break;
		}
		else
		{	if (!soap_in_ns__UserLog(soap, tag, &n, "ns:UserLog"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__UserLog));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__UserLog));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__UserLog));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__UserLog>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__UserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__UserLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__UserLog> *p;
	size_t k = sizeof(std::vector<ns__UserLog> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__UserLog> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__UserLog> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__UserLog>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__UserLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__ActivityLog(struct soap *soap, std::vector<ns__ActivityLog> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__ActivityLog(struct soap *soap, const std::vector<ns__ActivityLog> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__ActivityLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__ActivityLog(struct soap *soap, const char *tag, int id, const std::vector<ns__ActivityLog> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__ActivityLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__ActivityLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__ActivityLog(struct soap *soap, const char *tag, std::vector<ns__ActivityLog> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__ActivityLog(soap)))
			return NULL;
		ns__ActivityLog n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__ActivityLog, SOAP_TYPE_std__vectorTemplateOfns__ActivityLog, sizeof(ns__ActivityLog), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__ActivityLog(soap, tag, NULL, "ns:ActivityLog"))
				break;
		}
		else
		{	if (!soap_in_ns__ActivityLog(soap, tag, &n, "ns:ActivityLog"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ActivityLog));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__ActivityLog));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ActivityLog));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__ActivityLog>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__ActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__ActivityLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__ActivityLog> *p;
	size_t k = sizeof(std::vector<ns__ActivityLog> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__ActivityLog> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__ActivityLog> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__ActivityLog>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__ActivityLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__ErrorCode(struct soap *soap, std::vector<ns__ErrorCode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__ErrorCode(struct soap *soap, const std::vector<ns__ErrorCode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__ErrorCode> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__ErrorCode(struct soap *soap, const char *tag, int id, const std::vector<ns__ErrorCode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__ErrorCode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__ErrorCode> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__ErrorCode(struct soap *soap, const char *tag, std::vector<ns__ErrorCode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__ErrorCode(soap)))
			return NULL;
		ns__ErrorCode n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__ErrorCode, SOAP_TYPE_std__vectorTemplateOfns__ErrorCode, sizeof(ns__ErrorCode), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__ErrorCode(soap, tag, NULL, "ns:ErrorCode"))
				break;
		}
		else
		{	if (!soap_in_ns__ErrorCode(soap, tag, &n, "ns:ErrorCode"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ErrorCode));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__ErrorCode));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ErrorCode));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__ErrorCode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__ErrorCode(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__ErrorCode> *p;
	size_t k = sizeof(std::vector<ns__ErrorCode> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__ErrorCode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__ErrorCode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__ErrorCode>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__ErrorCode, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__CityLocation(struct soap *soap, std::vector<ns__CityLocation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__CityLocation(struct soap *soap, const std::vector<ns__CityLocation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__CityLocation> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__CityLocation(struct soap *soap, const char *tag, int id, const std::vector<ns__CityLocation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__CityLocation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__CityLocation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__CityLocation(struct soap *soap, const char *tag, std::vector<ns__CityLocation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__CityLocation(soap)))
			return NULL;
		ns__CityLocation n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__CityLocation, SOAP_TYPE_std__vectorTemplateOfns__CityLocation, sizeof(ns__CityLocation), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__CityLocation(soap, tag, NULL, "ns:CityLocation"))
				break;
		}
		else
		{	if (!soap_in_ns__CityLocation(soap, tag, &n, "ns:CityLocation"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__CityLocation));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__CityLocation));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__CityLocation));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__CityLocation>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__CityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__CityLocation(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__CityLocation> *p;
	size_t k = sizeof(std::vector<ns__CityLocation> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__CityLocation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__CityLocation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__CityLocation>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__CityLocation, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__string(soap)))
			return NULL;
		std::string n;
		soap_default_xsd__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__string, SOAP_TYPE_std__vectorTemplateOfxsd__string, sizeof(std::string), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_xsd__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_xsd__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__string, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__DeviceRules(struct soap *soap, std::vector<ns__DeviceRules> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__DeviceRules(struct soap *soap, const std::vector<ns__DeviceRules> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__DeviceRules> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__DeviceRules(struct soap *soap, const char *tag, int id, const std::vector<ns__DeviceRules> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__DeviceRules> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__DeviceRules> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__DeviceRules(struct soap *soap, const char *tag, std::vector<ns__DeviceRules> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__DeviceRules(soap)))
			return NULL;
		ns__DeviceRules n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__DeviceRules, SOAP_TYPE_std__vectorTemplateOfns__DeviceRules, sizeof(ns__DeviceRules), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__DeviceRules(soap, tag, NULL, "ns:DeviceRules"))
				break;
		}
		else
		{	if (!soap_in_ns__DeviceRules(soap, tag, &n, "ns:DeviceRules"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__DeviceRules));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__DeviceRules));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__DeviceRules));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__DeviceRules>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__DeviceRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__DeviceRules(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__DeviceRules> *p;
	size_t k = sizeof(std::vector<ns__DeviceRules> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__DeviceRules> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__DeviceRules> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__DeviceRules>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__DeviceRules, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfstd__string, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__Device(struct soap *soap, std::vector<ns__Device> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__Device(struct soap *soap, const std::vector<ns__Device> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__Device> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__Device(struct soap *soap, const char *tag, int id, const std::vector<ns__Device> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__Device> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__Device> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__Device(struct soap *soap, const char *tag, std::vector<ns__Device> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__Device(soap)))
			return NULL;
		ns__Device n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__Device, SOAP_TYPE_std__vectorTemplateOfns__Device, sizeof(ns__Device), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__Device(soap, tag, NULL, "ns:Device"))
				break;
		}
		else
		{	if (!soap_in_ns__Device(soap, tag, &n, "ns:Device"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Device));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__Device));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Device));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__Device>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__Device(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__Device(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__Device> *p;
	size_t k = sizeof(std::vector<ns__Device> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__Device> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__Device> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__Device>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__Device, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, std::vector<ns__DeviceStatusLog> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, const std::vector<ns__DeviceStatusLog> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__DeviceStatusLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, const char *tag, int id, const std::vector<ns__DeviceStatusLog> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__DeviceStatusLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__DeviceStatusLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, const char *tag, std::vector<ns__DeviceStatusLog> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__DeviceStatusLog(soap)))
			return NULL;
		ns__DeviceStatusLog n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__DeviceStatusLog, SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog, sizeof(ns__DeviceStatusLog), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__DeviceStatusLog(soap, tag, NULL, "ns:DeviceStatusLog"))
				break;
		}
		else
		{	if (!soap_in_ns__DeviceStatusLog(soap, tag, &n, "ns:DeviceStatusLog"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__DeviceStatusLog));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__DeviceStatusLog));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__DeviceStatusLog));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__DeviceStatusLog>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__DeviceStatusLog> *p;
	size_t k = sizeof(std::vector<ns__DeviceStatusLog> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__DeviceStatusLog> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__DeviceStatusLog> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__DeviceStatusLog>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__Sensor(struct soap *soap, std::vector<ns__Sensor> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__Sensor(struct soap *soap, const std::vector<ns__Sensor> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__Sensor> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__Sensor(struct soap *soap, const char *tag, int id, const std::vector<ns__Sensor> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__Sensor> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__Sensor> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__Sensor(struct soap *soap, const char *tag, std::vector<ns__Sensor> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__Sensor(soap)))
			return NULL;
		ns__Sensor n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__Sensor, SOAP_TYPE_std__vectorTemplateOfns__Sensor, sizeof(ns__Sensor), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__Sensor(soap, tag, NULL, "ns:Sensor"))
				break;
		}
		else
		{	if (!soap_in_ns__Sensor(soap, tag, &n, "ns:Sensor"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Sensor));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__Sensor));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Sensor));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__Sensor>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__Sensor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__Sensor(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__Sensor> *p;
	size_t k = sizeof(std::vector<ns__Sensor> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__Sensor> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__Sensor> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__Sensor>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__Sensor, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__long(struct soap *soap, std::vector<LONG64> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__long(struct soap *soap, const std::vector<LONG64> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__long(struct soap *soap, const char *tag, int id, const std::vector<LONG64> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<LONG64> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__long(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<LONG64> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__long(struct soap *soap, const char *tag, std::vector<LONG64> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__long(soap)))
			return NULL;
		LONG64 n;
		soap_default_xsd__long(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__long, SOAP_TYPE_std__vectorTemplateOfxsd__long, sizeof(LONG64), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_xsd__long(soap, tag, NULL, "xsd:long"))
				break;
		}
		else
		{	if (!soap_in_xsd__long(soap, tag, &n, "xsd:long"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<LONG64>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__long(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<LONG64> *p;
	size_t k = sizeof(std::vector<LONG64> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<LONG64> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<LONG64> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<LONG64>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__long, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__User(struct soap *soap, std::vector<ns__User> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__User(struct soap *soap, const std::vector<ns__User> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__User> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__User(struct soap *soap, const char *tag, int id, const std::vector<ns__User> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__User> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__User> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__User(struct soap *soap, const char *tag, std::vector<ns__User> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__User(soap)))
			return NULL;
		ns__User n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__User, SOAP_TYPE_std__vectorTemplateOfns__User, sizeof(ns__User), 0, Server_Soap_finsert, Server_Soap_fbase))
				break;
			if (!soap_in_ns__User(soap, tag, NULL, "ns:User"))
				break;
		}
		else
		{	if (!soap_in_ns__User(soap, tag, &n, "ns:User"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__User));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__User));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__User));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__User>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__User(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__User> *p;
	size_t k = sizeof(std::vector<ns__User> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__User> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__User> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__User>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__User, n, Server_Soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of Server_SoapC.cpp */
