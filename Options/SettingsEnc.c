/**
 * This file was generated by the Objective Systems XBinder(tm) Compiler
 * (http://www.obj-sys.com).  Version: 2.3.3 (DEMO), Date: 24-Dec-2014.
 * Copyright (c) 2003-2012 Objective Systems, Inc.
 *
 * Permission is hereby granted to redistribute this file with the
 * condition that this copyright notice be present and not altered.
 */
#include "Settings.h"
#include "rtxsrc/rtxErrCodes.h"

/**
 * Percentage
 */
int XmlET_Percentage
  (OSCTXT* pctxt, Percentage value,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (value > 100) {
      return LOG_RTERRNEW2 (pctxt, RTERR_CONSVIO,
         rtxErrAddStrParm (pctxt, "Percentage"),
         rtxErrAddUIntParm (pctxt, (unsigned int)value));
   }
   stat = rtXmlEncUInt (pctxt, value, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * PhoneNumber
 */
int XmlET_PhoneNumber
  (OSCTXT* pctxt, PhoneNumber* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (!rtxMatchPattern (pctxt, pvalue->value, 
      OSUTF8("([1-9][0-9]{0,2})(-[1-9][0-9]{0,4})?(-[1-9][0-9]{0,13})(-[0-9]+)?"))) {
      return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
         rtxErrAddStrParm (pctxt, "PhoneNumber"),
         rtxErrAddStrParm (pctxt, (const char*)pvalue->value));
   }

   stat = rtXmlEncString (pctxt, pvalue, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * PhoneCountryCode
 */
int XmlET_PhoneCountryCode
  (OSCTXT* pctxt, PhoneCountryCode value,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (value < 1 || value > 999) {
      return LOG_RTERRNEW2 (pctxt, RTERR_CONSVIO,
         rtxErrAddStrParm (pctxt, "PhoneCountryCode"),
         rtxErrAddUIntParm (pctxt, (unsigned int)value));
   }
   stat = rtXmlEncUInt (pctxt, value, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * PhoneAreaCode
 */
int XmlET_PhoneAreaCode
  (OSCTXT* pctxt, PhoneAreaCode value,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (value < 1 || value > 99999) {
      return LOG_RTERRNEW2 (pctxt, RTERR_CONSVIO,
         rtxErrAddStrParm (pctxt, "PhoneAreaCode"),
         rtxErrAddUIntParm (pctxt, (unsigned int)value));
   }
   stat = rtXmlEncUInt (pctxt, value, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * PhoneSubscriberNumber
 */
int XmlET_PhoneSubscriberNumber
  (OSCTXT* pctxt, PhoneSubscriberNumber value,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (value < 1 || value > OSI64CONST(99999999999999)) {
      return LOG_RTERRNEW2 (pctxt, RTERR_CONSVIO,
         rtxErrAddStrParm (pctxt, "PhoneSubscriberNumber"),
         rtxErrAddUInt64Parm (pctxt, (OSUINT64)value));
   }
   stat = rtXmlEncUInt64 (pctxt, value, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * PhoneExtensionNumber
 */
int XmlET_PhoneExtensionNumber
  (OSCTXT* pctxt, PhoneExtensionNumber value,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   stat = rtXmlEncUInt64 (pctxt, value, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * PhoneNumberStruct
 */
int XmlET_PhoneNumberStruct
  (OSCTXT* pctxt, PhoneNumberStruct* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, pNS, &pvalue->_nsAttrs
      , FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt, &pvalue->_nsAttrs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode country */
   stat = XmlET_PhoneCountryCode (pctxt, pvalue->country
      , OSUTF8("country"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode area */
   if (pvalue->m.areaPresent) {
      stat = XmlET_PhoneAreaCode (pctxt, pvalue->area, OSUTF8("area"), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   /* encode subscriber */
   stat = XmlET_PhoneSubscriberNumber (pctxt, pvalue->subscriber
      , OSUTF8("subscriber"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode extension */
   if (pvalue->m.extensionPresent) {
      stat = XmlET_PhoneExtensionNumber (pctxt, pvalue->extension
         , OSUTF8("extension"), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   stat = rtXmlEncEndElement (pctxt, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * IPv4Address
 */
int XmlET_IPv4Address
  (OSCTXT* pctxt, IPv4Address* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (!rtxMatchPattern (pctxt, pvalue->value, 
      OSUTF8("((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])"))) {
      return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
         rtxErrAddStrParm (pctxt, "IPv4Address"),
         rtxErrAddStrParm (pctxt, (const char*)pvalue->value));
   }

   stat = rtXmlEncString (pctxt, pvalue, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * Port
 */
int XmlET_Port
  (OSCTXT* pctxt, Port value,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (value < 1) {
      return LOG_RTERRNEW2 (pctxt, RTERR_CONSVIO,
         rtxErrAddStrParm (pctxt, "Port"),
         rtxErrAddUIntParm (pctxt, (unsigned int)value));
   }
   stat = rtXmlEncUInt (pctxt, value, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * IPv4Endpoint
 */
int XmlET_IPv4Endpoint
  (OSCTXT* pctxt, IPv4Endpoint* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (!rtxMatchPattern (pctxt, pvalue->value, 
      OSUTF8("((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]):[1-9][0-9]{0,4}"))) {
      return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
         rtxErrAddStrParm (pctxt, "IPv4Endpoint"),
         rtxErrAddStrParm (pctxt, (const char*)pvalue->value));
   }

   stat = rtXmlEncString (pctxt, pvalue, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * IPv4EndpointStruct
 */
int XmlET_IPv4EndpointStruct
  (OSCTXT* pctxt, IPv4EndpointStruct* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, pNS, &pvalue->_nsAttrs
      , FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt, &pvalue->_nsAttrs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode address */
   stat = XmlET_IPv4Address (pctxt, &(pvalue->address), OSUTF8("address"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode port */
   stat = XmlET_Port (pctxt, pvalue->port, OSUTF8("port"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * Temperature
 */
int XmlET_Temperature
  (OSCTXT* pctxt, Temperature value,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Temperature_ToString (value), elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * Database
 */
int XmlET_Database
  (OSCTXT* pctxt, Database* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, pNS, &pvalue->_nsAttrs
      , FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt, &pvalue->_nsAttrs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode server */
   stat = XmlET_IPv4Address (pctxt, &(pvalue->server), OSUTF8("server"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode port */
   stat = XmlET_Port (pctxt, pvalue->port, OSUTF8("port"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode user */
   stat = rtXmlEncString (pctxt, &(pvalue->user), OSUTF8("user"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode password */
   stat = rtXmlEncString (pctxt, &(pvalue->password), OSUTF8("password"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * EmailAddress
 */
int XmlET_EmailAddress
  (OSCTXT* pctxt, EmailAddress* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   if (!rtxMatchPattern (pctxt, pvalue->value, 
      OSUTF8("([a-zA-Z0-9_\\-])([a-zA-Z0-9_\\-\\.]*)@(\\[((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}|((([a-zA-Z0-9\\-]+)\\.)+))([a-zA-Z]{2,}|(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\])"))) {
      return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
         rtxErrAddStrParm (pctxt, "EmailAddress"),
         rtxErrAddStrParm (pctxt, (const char*)pvalue->value));
   }

   stat = rtXmlEncString (pctxt, pvalue, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * Settings
 */
int XmlET_Settings
  (OSCTXT* pctxt, Settings* pvalue,
   const OSUTF8CHAR* elemName, OSXMLNamespace* pNS)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, pNS, &pvalue->_nsAttrs
      , FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt, &pvalue->_nsAttrs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode name */
   stat = rtXmlEncString (pctxt, &(pvalue->name), OSUTF8("name"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode database */
   stat = XmlET_Database (pctxt, &(pvalue->database), OSUTF8("database"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**
 * Global element functions.  These functions encode or 
 * decode complete XML documents.  They are generated for global 
 * elements that are either:
 *
 * 1) not referenced by any other types, or
 * 2) explicitly declared to be a PDU using the -pdu command line
 *    option, or
 * 3) explicitly declared to be a PDU using the <isPDU/> 
 *    configuration file element.
 */
int XmlE_setting (OSCTXT* pctxt, Settings* pvalue)
{
   int stat = 0;
   OSXMLNamespace* pNS = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("setting"), pNS, &pvalue
      ->_nsAttrs, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlET_Settings (pctxt, pvalue, 0, pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("setting"), pNS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndDocument (pctxt);

   return stat;
}

